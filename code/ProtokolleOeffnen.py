# -*- coding: utf-8 -*-
"""
/***************************************************************************
 KanalManagementDockWidget
                                 A QGIS plugin
 Werkzeuge rund um das Kanalmanagement
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-10
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Armin Matzl
        email                : arminmatzl@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math
import sqlite3
import pandas as pd
import json
from datetime import datetime
from qgis.PyQt.QtCore import Qt, QRegExp, QLine, pyqtSignal, QSignalBlocker, QVariant, QDateTime
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtGui import  QRegExpValidator
from qgis.utils import iface
from qgis.gui import QgsMessageBar, QgsMapToolIdentifyFeature, QgsMapToolPan, QgsSpinBox
from qgis.core import QgsVectorLayer, QgsMessageLog, QgsGeometry, Qgis, QgsProject, QgsFeature,QgsPoint, edit,QgsExpressionContextUtils
from qgis.PyQt.QtWidgets import (QMessageBox, QCompleter, QDialog, QGridLayout, QLabel, QComboBox,
                                QDialogButtonBox,QTableWidgetItem, QTableWidget,
                                QLineEdit, QStyledItemDelegate, QListWidget, QListWidgetItem, QCheckBox,
                                QHBoxLayout, QPushButton)


# eigene klassen
from ..tools.mapIdentify import selectTool
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__),"../","ui", 'protokolle_oeffnen.ui'))


class Open(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    load_haltung = pyqtSignal()
    load_schacht = pyqtSignal()
    #load_leitung = pyqtSignal()

    def __init__(self,iface, parent=None):
        """Constructor."""
        super(Open, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setCursor(Qt.WaitCursor)
        self.iface = iface
        self.setupUi(self)
        #self.txt_haltungID.setVisible(False) # Textfeld mit HaltungsID verbergen
        #self.load_attribute_names_to_dict()
        self.setup_ui_dict()
        #self.haltungNr_add_completer()
        #self.schachtNr_add_completer()

        #connectors definieren
        """
        self.button_select_haltung.clicked.connect(lambda: self.select_object(self.layer_object["haltung"],self.variablen["attribut_haltungNr"], "Haltung"))
        self.txt_haltungNr.returnPressed.connect(lambda: self.load_layer_from_textField("Haltung"))
        self.txt_haltungNr.textEdited.connect(self.change_col_haltungNr)

        self.button_select_schacht.clicked.connect(lambda: self.select_object(self.layer_object["schacht"],self.variablen["attribut_schachtNr"],"Schacht"))
        self.txt_schachtNr.returnPressed.connect(lambda: self.load_layer_from_textField("Schacht"))
        self.txt_schachtNr.textEdited.connect(self.change_col_schachtNr)

        self.button_h_protokoll.clicked.connect(lambda: self.open_file(self.tv_pfad[self.h_combobox_protokoll.currentIndex()]))
        self.button_h_dp.clicked.connect(lambda: self.open_file(self.druck_pfad[self.h_combobox_druck.currentIndex()]))
        self.button_h_video.clicked.connect(lambda: self.open_file(self.video_pfad[self.h_combobox_video.currentIndex()]))
        self.button_h_protokoll_video.clicked.connect(lambda: self.open_file(self.tv_pfad[self.button_h_protokoll.currentIndex()],self.video_pfad[self.combobox_video.currentIndex()]))
        self.button_zoom_haltung.clicked.connect(lambda: self.zoom_to_object(self.layer_object["haltung"], self.features["haltung"].id()))
        
        self.button_s_protokoll.clicked.connect(lambda: self.open_file(self.protokoll_pfad[self.s_combobox_protokoll.currentIndex()]))
        self.button_s_video_schacht.clicked.connect(lambda: self.open_file(self.video_schacht_pfad[self.s_combobox_video.currentIndex()]))
        self.button_s_protokoll_video.clicked.connect(lambda: self.open_file(self.protokoll_pfad[self.s_combobox_protokoll.currentIndex()],self.video_schacht_pfad[self.s_combobox_video.currentIndex()]))
        self.button_zoom_schacht.clicked.connect(lambda: self.zoom_to_object(self.layer_object["schacht"], self.features["schacht"].id()))

        #wenn leitung definiert dann leitung initialisieren

        if self.leitung_defined:
            self.leitungNr_add_completer()

            self.button_select_leitung.clicked.connect(lambda: self.select_object(self.layer_object["leitung"],self.variablen["attribut_leitungNr"], "Leitung"))
            self.txt_leitungNr.returnPressed.connect(lambda: self.load_layer_from_textField("Leitung"))
            self.txt_leitungNr.textEdited.connect(self.change_col_leitungNr)

            self.button_tv_leitung.clicked.connect(lambda: self.open_file(self.tv_pfad_leitung[self.combobox_tv_leitung.currentIndex()]))
            self.button_druck_leitung.clicked.connect(lambda: self.open_file(self.druck_pfad_leitung[self.combobox_druck_leitung.currentIndex()]))
            self.button_video_leitung.clicked.connect(lambda: self.open_file(self.video_pfad_leitung[self.combobox_video_leitung.currentIndex()]))
            self.button_tv_video_leitung.clicked.connect(lambda: self.open_file(self.tv_pfad_leitung[self.combobox_tv_leitung.currentIndex()],self.video_pfad_leitung[self.combobox_video_leitung.currentIndex()]))
            self.button_zoom_leitung.clicked.connect(lambda: self.zoom_to_object(self.layer_object["leitung"], self.features["leitung"].id()))
        else:
            self.tabWidget.removeTab(2)
        
        """
        self.tabWidget.currentChanged.connect(self.tab_changed)
        
        self.setCursor(Qt.ArrowCursor)

   
    def tab_changed(self,tab_nr):
        try:
            tool = self.iface.mapCanvas().mapTool().toolName()

            if tool == "Kanalmanagement Objekt abfragen":
                if tab_nr == 0:
                    self.select_object(self.layer_object["haltung"],self.variablen["attribut_haltungNr"], "Haltung")
                elif tab_nr == 1:
                    self.select_object(self.layer_object["schacht"],self.variablen["attribut_schachtNr"], "Schacht")
                elif tab_nr == 2:
                    self.select_object(self.layer_object["leitung"],self.variablen["attribut_leitungNr"], "Leitung")
        except:
            pass

    def setup_ui_dict(self):
        saved_dict = json.loads(QgsExpressionContextUtils.projectScope(QgsProject.instance()).variable('Dokumente_Setup'))
        self.setup_dict = {
            "haltung" : {
                "ui": {
                    "protokoll":
                    {
                        "label" : self.h_protokoll_label,
                        "txt" : self.txt_h_protokoll_anzahl,
                        "combobox" : self.h_combobox_protokoll,
                        "button" : self.button_h_protokoll
                    },
                    "dp" :
                    {
                        "label" : self.h_dp_label,
                        "txt" : self.txt_h_dp_anzahl,
                        "combobox" : self.h_combobox_dp,
                        "button" : self.button_h_dp
                    },
                    "video":
                    {
                        "label" : self.h_video_label,
                        "txt" : self.txt_h_video_anzahl,
                        "combobox" : self.h_combobox_video,
                        "button" : self.button_h_video
                    },
                    "andere":
                    {
                        "label" : self.h_andere_label,
                        "txt" : self.txt_h_andere_anzahl,
                        "combobox" : self.h_combobox_andere,
                        "button" : self.button_h_andere
                    },
                    "button_select" : self.button_select_haltung,
                    "txt_nr" : self.txt_haltungNr,
                    "txt_ergebnisDP" : self.txt_h_ergebnisDP,
                    "button_zoom" : self.button_zoom_haltung,
                    "button_protokoll_video" : self.button_h_protokoll_video
                },
                "variablen": {
                    "layer_protokolle" : "Inspektionsdaten_Haltung",
                    "layer_id" : saved_dict["haltung"]["layer_id"],
                    "attribut_id" : saved_dict["haltung"]["attribut_id"],
                    "1_attribut" : saved_dict["haltung"]["1_attribut"],
                    "attribut1" : saved_dict["haltung"]["attribut1"],
                    "attribut2" : saved_dict["haltung"]["attribut2"],
                    "typ" : saved_dict["haltung"]["typ"],
                    "bezeichnung_protokoll" : saved_dict["haltung"]["bezeichnung_protokoll"],
                    "bezeichnung_dp" : saved_dict["haltung"]["bezeichnung_dp"] ,
                    "bezeichnung_video" : saved_dict["haltung"]["bezeichnung_video"],
                    "ergebnis_dp" : saved_dict["haltung"]["ergebnis_dp"],
                    "tab_id": 0
                }
            },
            "schacht": {
                "ui": {
                    "protokoll":
                    {
                        "label" : self.s_protokoll_label,
                        "txt" : self.txt_s_protokoll_anzahl,
                        "combobox" : self.s_combobox_protokoll,
                        "button" : self.button_s_protokoll
                    },
                    "dp" :
                    {
                        "label" : self.s_dp_label,
                        "txt" : self.txt_s_dp_anzahl,
                        "combobox" : self.s_combobox_dp,
                        "button" : self.button_s_dp
                    },
                    "video":
                    {
                        "label" : self.s_video_label,
                        "txt" : self.txt_s_video_anzahl,
                        "combobox" : self.s_combobox_video,
                        "button" : self.button_s_video
                    },
                    "andere":
                    {
                        "label" : self.s_andere_label,
                        "txt" : self.txt_s_andere_anzahl,
                        "combobox" : self.s_combobox_andere,
                        "button" : self.button_s_andere
                    },
                    "button_select" : self.button_select_schacht,
                    "txt_nr" : self.txt_schachtNr,
                    "txt_ergebnisDP" : self.txt_s_ergebnisDP,
                    "button_zoom" : self.button_zoom_schacht,
                    "button_protokoll_video" : self.button_s_protokoll_video
                },
                "variablen": {
                    "layer_protokolle" : "Inspektionsdaten_Schacht",
                    "layer_id" : saved_dict["schacht"]["layer_id"],
                    "attribut_id" : saved_dict["schacht"]["attribut_id"],
                    "1_attribut" : saved_dict["schacht"]["1_attribut"],
                    "attribut1" : saved_dict["schacht"]["attribut1"],
                    "attribut2" : saved_dict["schacht"]["attribut2"],
                    "typ" : saved_dict["schacht"]["typ"],
                    "bezeichnung_protokoll" : saved_dict["schacht"]["bezeichnung_protokoll"],
                    "bezeichnung_dp" : saved_dict["schacht"]["bezeichnung_dp"] ,
                    "bezeichnung_video" : saved_dict["schacht"]["bezeichnung_video"],
                    "ergebnis_dp" : saved_dict["schacht"]["ergebnis_dp"],
                    "tab_id": 1
                }
            },
            "leitung": {
                "ui": {
                    "protokoll":
                    {
                        "label" : self.l_protokoll_label,
                        "txt" : self.txt_l_protokoll_anzahl,
                        "combobox" : self.l_combobox_protokoll,
                        "button" : self.button_l_protokoll
                    },
                    "dp" :
                    {
                        "label" : self.l_dp_label,
                        "txt" : self.txt_l_dp_anzahl,
                        "combobox" : self.l_combobox_dp,
                        "button" : self.button_l_dp
                    },
                    "video":
                    {
                        "label" : self.l_video_label,
                        "txt" : self.txt_l_video_anzahl,
                        "combobox" : self.l_combobox_video,
                        "button" : self.button_l_video
                    },
                    "andere":
                    {
                        "label" : self.l_andere_label,
                        "txt" : self.txt_l_andere_anzahl,
                        "combobox" : self.l_combobox_andere,
                        "button" : self.button_l_andere
                    },
                    "button_select" : self.button_select_leitung,
                    "txt_nr" : self.txt_leitungNr,
                    "txt_ergebnisDP" : self.txt_l_ergebnisDP,
                    "button_zoom" : self.button_zoom_leitung,
                    "button_protokoll_video" : self.button_l_protokoll_video
                },
                "variablen": {
                    "layer_protokolle" : "Inspektionsdaten_Leitung",
                    "layer_id" : saved_dict["leitung"]["layer_id"],
                    "attribut_id" : saved_dict["leitung"]["attribut_id"],
                    "1_attribut" : saved_dict["leitung"]["1_attribut"],
                    "attribut1" : saved_dict["leitung"]["attribut1"],
                    "attribut2" : saved_dict["leitung"]["attribut2"],
                    "typ" : saved_dict["leitung"]["typ"],
                    "bezeichnung_protokoll" : saved_dict["leitung"]["bezeichnung_protokoll"],
                    "bezeichnung_dp" : saved_dict["leitung"]["bezeichnung_dp"] ,
                    "bezeichnung_video" : saved_dict["leitung"]["bezeichnung_video"],
                    "ergebnis_dp" : saved_dict["leitung"]["ergebnis_dp"],
                    "tab_id": 2
                }
            },
            "allgemein": {
                    "trennzeichen" : saved_dict["trennzeichen"],
                    "datum" : saved_dict["datum"],
                    "case_bezeichnung" : saved_dict["case_bezeichnung"],
                    "case_attribut" : saved_dict["case_attribut"],
                    "case_typ" : saved_dict["case_typ"],
                    "zoom_massstab" : saved_dict["zoom_massstab"],
                    "ignorieren" : saved_dict["ignorieren"],
                    "db_protokolle_path" : saved_dict["db_protokolle_path"]
            }  
        }

        self.layer_object = {}
        for typ, values in self.setup_dict.items():
            if typ != "allgemein":
                typ_dict = self.setup_dict[typ]
                if QgsProject.instance().mapLayer(typ_dict["variablen"]["layer_id"]) == None:
                    self.tabWidget.removeTab(typ_dict["variablen"]["tab_id"])
                    typ_dict["vorhanden"] = False
                    continue

                else:
                    typ_dict["vorhanden"] = True
                    if QgsProject.instance().mapLayer(typ_dict["variablen"]["layer_id"]).isValid():
                        self.layer_object[typ] = QgsProject.instance().mapLayer(typ_dict["variablen"]["layer_id"])
                        self.layer_object[f"{typ}_clone"] = QgsProject.instance().mapLayer(typ_dict["variablen"]["layer_id"]).clone()
                if typ_dict["variablen"]["bezeichnung_protokoll"][0] == "":
                    for element in typ_dict["ui"]["protokoll"].values():
                        element.hide()
                    typ_dict["ui"]["protokoll"]["vorhanden"] = False
                else:
                    typ_dict["ui"]["protokoll"]["vorhanden"] = True

                if typ_dict["variablen"]["bezeichnung_dp"][0] == "":
                    for element in typ_dict["ui"]["dp"].values():
                        element.hide()
                    typ_dict["ui"]["bezeichnung_dp"]["vorhanden"] = False
                else:
                    typ_dict["ui"]["bezeichnung_dp"]["vorhanden"] = True

                if typ_dict["variablen"]["bezeichnung_video"][0] == "":
                    for element in typ_dict["ui"]["video"].values():
                        element.hide()
                    typ_dict["ui"]["bezeichnung_video"]["vorhanden"] = False
                else:
                    typ_dict["ui"]["bezeichnung_video"]["vorhanden"] = True

        self.features = {}

        
        

    def closeEvent(self, event):
        """
        Wird bei beenden des Fenserts ausgeführt
        """
        self.closingPlugin.emit()
        event.accept()
        panTool = QgsMapToolPan(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(panTool)
        self.deleteLater()

    def add_completer(self,typ):
        """
        Fügt einen Completer für QLineEdit des eindeutigen Objektnamen für manuelle Eingabe ein
        """
        id_idx = self.layer_object[typ].fields().indexOf(self.setup_dict[typ]["variablen"]["attribut_id"])
        objekte = sorted(self.layer_object[typ].uniqueValues(id_idx))
        objekte = [element for element in objekte if not isinstance(element,QVariant)]
        completer = QCompleter(objekte)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.setup_dict[typ]["ui"]["txt_nr"].setCompleter(completer)

    def select_object(self, selection_layer, name_shown, object_type):
        """
        Aktion zum Wählen einer Haltung
        """
        self.selection = selectTool(iface = self.iface,
                                    name_shown = name_shown, #Attribut das in Auswahl angezeigt wird
                                    selection_layer = selection_layer
                                    )

        self.selection.objectFound.connect(lambda feature, object_type = object_type: self.feature_selected(feature, object_type))
        self.iface.mapCanvas().setMapTool(self.selection)
    
    def feature_selected(self,feature, object_type):
        self.features[typ] = feature
        self.load_layer(object_type = object_type)
    
    def change_txt_col(self,typ, valid =None):
        if valid != None:
            self.setup_dict[typ]["ui"]["txt_nr"].setStyleSheet("")
            self.setup_dict[typ]["ui"]["button_zoom"].setEnabled(True)
        else:
            self.setup_dict[typ]["ui"]["txt_nr"].setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.setup_dict[typ]["ui"]["button_zoom"].setEnabled(False)

    def load_layer_from_textField(self, object_type):
        self.setCursor(Qt.WaitCursor)
        objekt = self.setup_dict[object_type]
        filter = self.layer_object[object_type].subsetString()
        self.layer_object[object_type].setSubsetString(f"{object["variablen"]['attribut_id']}='{object["ui"]["txt_nr"].text()}'")

        error_msg = {
            "haltung" : ["Haltung nicht gefunden", "Die angegebene Haltungsnummer ist ungültig."],
            "schacht" : ["Schacht nicht gefunden", "Die angegebene Schachtnummer ist ungültig."]
            "leitung" : ["Leitung nicht gefunden", "Die angegebene Leitungsnummer ist ungültig."]
        }
        if self.layer_object[object_type].featureCount() == 1:
            feature = QgsFeature()
            self.layer_object[object_type].getFeatures().nextFeature(feature)
            self.features[object_type] = feature
            self.load_layer(load_from_txt_field = True, object_type = object_type)
            self.change_txt_col(object_type, valid = True)
        else:
            self.clear_all()
            self.iface.messageBar().pushMessage(error_msg[object_type][0],error_msg[object_type][1], level=Qgis.Warning, duration=2)
            self.setup_dict[object_type]["ui"]["button_zoom"].setEnabled(True)
        self.layer_object[object_type].setSubsetString(filter)
        
        self.setCursor(Qt.ArrowCursor)

    def load_layer(self, object_type, load_from_txt_field = False): 
        objekt = self.setup_dict[object_type]          
        if not load_from_txt_field:
            self.txt_haltungNr.setText(self.features[object_type].attribute(objekt["variablen"]["attribut_id"]))
        self.change_txt_col(object_type, valid = True)        

        if object["ui"]["dp"]["vorhanden"]:    
            try:
                ergebnisDP = str(self.features[object_type].attribute(objekt["variablen"]["ergebnis_dp"]))
            except:
                ergebnisDP = 'NULL'
            if ergebnisDP == "NULL":
                ergebnisDP = "keine DP"
            objekt["ui"]["txt_ergebnisDP"].setText(ergebnisDP)
            self.change_col_ergebnisDP(object_type)

        #self.load_haltung.emit()

        self.load_protokolle(object_type)
 
    def clear_all(self):
        # Haltung Tab
        for objekt, ui in self.setup_dict.items():
            if objekt != "allgemein":
                for typ in ui.items():
                    if isinstance(typ,dict):
                        if typ["vorhanden"]:
                            typ["txt"].setText("")
                            typ["combobox"].clear()
                            typ["button"].setEnabled(False)
                ui["txt_nr"].setText("")
                ui["txt_ergebnisDP"].setText("")
                ui["button_zoom"].setEnabled(False)
                ui["button_protokoll_video"].setEnabled(False)

 
    def zoom_to_object(self,layer, id):
        layer.selectByIds([id], QgsVectorLayer.SetSelection)
        bbox = layer.boundingBoxOfSelected()
        self.iface.mapCanvas().setExtent(bbox)
        scale = self.setup_dict["variablen"]["zoom_massstab"]
        self.iface.mapCanvas().zoomScale(scale)
        self.iface.mapCanvas().refresh()

    ################
    #
    # hier weiter coden
    #
    ###############
    def load_protokolle(self, object_type):
        objekt = self.setup_dict[object_type]
        protokolle = QgsVectorLayer(self.setup_dict["allgemein"]["db_protokolle_path"]+"|layername="+self.setup_dict[object_type]["variablen"]["layer_protokolle"], "Protokolle", "ogr")
        if objekt["variablen"]["1_attribut"]:
            if self.setup_dict["allgemein"]["case_attribut"]:
                protokolle.setSubsetString(f"lower(attribut1) = lower('{objekt["variablen"]["attribut1"]}')")
            else:
                protokolle.setSubsetString(f"attribut1 = '{objekt["variablen"]["attribut1"]}'")
        else:
            if self.setup_dict["allgemein"]["case_attribut"]:
                protokolle.setSubsetString(f"lower(attribut1) = lower('{objekt["variablen"]["attribut1"]}') & lower(attribut2) = lower('{objekt["variablen"]["attribut2"]}')")
            else:
                protokolle.setSubsetString(f"attribut1 = '{objekt["variablen"]["attribut1"]}' & attribut2 = '{objekt["variablen"]["attribut2"]}'")

        self.tv_pfad = []
        self.tv_datum = []
            
        self.video_pfad = []
        self.video_datum = []
            
        self.druck_pfad = []
        self.druck_datum = []

        for feature in protokolle.getFeatures():
            if feature.attribute("bezeichnung") in objekt["variablen"]["bezeichnung_protokoll"]:
                self.tv_pfad.append(feature.attribute("pfad"))
                if feature.attribute("datum") != '':
                    self.tv_datum.append(feature.attribute("datum"))
                else:
                    self.tv_datum.append("1900-01-01 00:00:00") # wenn datum fehlt
            elif "video" in feature.attribute("bez"):
                self.video_pfad.append(feature.attribute("pfad"))
                if feature.attribute("datum") != '':
                    self.video_datum.append(feature.attribute("datum"))
                else:
                    self.video_datum.append("1900-01-01 00:00:00")
            elif "druck" in feature.attribute("bez"):
                self.druck_pfad.append(feature.attribute("pfad"))
                if feature.attribute("datum") != '':
                    self.druck_datum.append(feature.attribute("datum"))
                else:
                    self.druck_datum.append("1900-01-01 00:00:00")

            self.tv_datum_strp = self.tv_datum
            self.video_datum_strp = self.video_datum
            self.druck_datum_strp = self.druck_datum

            tv_zip = sorted(zip(self.tv_datum_strp,self.tv_datum,self.tv_pfad), reverse = True)
            self.tv_datum_strp = [a for a,b,c in tv_zip]
            #self.tv_datum = [a.strftime("%d.%m.%Y") for a,b,c in tv_zip]
            self.tv_datum = [a.toString("dd.MM.yyyy") for a,b,c in tv_zip]
            self.tv_pfad = [c for a,b,c in tv_zip]

            video_zip = sorted(zip(self.video_datum_strp, self.video_datum, self.video_pfad), reverse = True)
            self.video_datum_strp = [a for a,b,c in video_zip]
            #self.video_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_zip]
            self.video_datum = [a.toString("dd.MM.yyyy") for a,b,c in video_zip]
            self.video_pfad = [c for a,b,c in video_zip]

            druck_zip = sorted(zip(self.druck_datum_strp, self.druck_datum, self.druck_pfad), reverse = True)
            self.druck_datum_strp = [a for a,b,c in druck_zip]
            #self.druck_datum = [a.strftime("%d.%m.%Y") for a,b,c in druck_zip]
            self.druck_datum = [a.toString("dd.MM.yyyy") for a,b,c in druck_zip]
            self.druck_pfad = [c for a,b,c in druck_zip]

            if len(self.tv_pfad) == 0 and len(self.video_pfad) == 0 and len(self.druck_pfad) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu dieser Haltung wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_tv.clear()
            self.txt_tv_anzahl.setText("")
            if len(self.tv_pfad) != 0:
                tv_pfad_short = [os.path.basename(f) for f in self.tv_pfad]
                tv_list = [list(i) for i in zip(self.tv_datum,tv_pfad_short)]
                tv_list = [":  ".join(i) for i in tv_list]
                self.combobox_tv.addItems(tv_list)
                self.txt_tv_anzahl.setText(str(len(self.tv_pfad)))
                self.button_tv.setEnabled(True)
            else:
                self.button_tv.setEnabled(False)
            # auswahl für druckprüfung einfügen
            self.combobox_druck.clear()
            self.txt_druck_anzahl.setText("")
            if len(self.druck_pfad) != 0:
                druck_pfad_short = [os.path.basename(f) for f in self.druck_pfad]
                druck_list = [list(i) for i in zip(self.druck_datum, druck_pfad_short)]
                druck_list = [":   ".join(i) for i in druck_list]
                self.combobox_druck.addItems(druck_list)
                self.txt_druck_anzahl.setText(str(len(self.druck_pfad)))
                self.button_druck.setEnabled(True)
            else:
                self.button_druck.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video.clear()
            self.txt_video_anzahl.setText("")
            if len(self.video_pfad) != 0:
                video_pfad_short = [os.path.basename(f) for f in self.video_pfad]
                video_list = [list(i) for i in zip(self.video_datum, video_pfad_short)]
                video_list = [":   ".join(i) for i in video_list]
                self.combobox_video.addItems(video_list)
                self.txt_video_anzahl.setText(str(len(self.video_pfad)))
                self.button_video.setEnabled(True)
            else:
                self.button_video.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_pfad) != 0 and len(self.tv_pfad) != 0:
                self.button_tv_video.setEnabled(True)
            else:
                self.button_tv_video.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Haltung {self.txt_haltungNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)
        elif object_type == "Schacht":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_schacht"], "Protokolle_Schacht", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_schachtNr.text()}')")

            self.protokoll_pfad = []
            self.protokoll_datum = []
                
            self.video_schacht_pfad = []
            self.video_schacht_datum = []

            for feature in protokolle.getFeatures():
                if feature.attribute("bez") in ["protokoll", "erhebungsblatt", "aufmaßblatt", "aufmassblatt"]:
                    self.protokoll_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.protokoll_datum.append(feature.attribute("datum"))
                    else:
                        self.protokoll_datum.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_schacht_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_schacht_datum.append(feature.attribute("datum"))
                    else:
                        self.video_schacht_datum.append("1900-01-01 00:00:00")


            #self.protokoll_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.protokoll_datum] # alt weil früher als string gespeichert
            self.protokoll_datum_strp = self.protokoll_datum
            #self.video_schacht_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.video_schacht_datum]# alt weil früher als string gespeichert
            self.video_schacht_datum_strp = self.video_schacht_datum

            protokoll_zip = sorted(zip(self.protokoll_datum_strp,self.protokoll_datum,self.protokoll_pfad), reverse = True)
            self.protokoll_datum_strp = [a for a,b,c in protokoll_zip]
            #self.protokoll_datum = [a.strftime("%d.%m.%Y") for a,b,c in protokoll_zip]
            self.protokoll_datum = [a.toString("dd.MM.yyyy") for a,b,c in protokoll_zip]
            self.protokoll_pfad = [c for a,b,c in protokoll_zip]

            video_schacht_zip = sorted(zip(self.video_schacht_datum_strp, self.video_schacht_datum, self.video_schacht_pfad), reverse = True)
            self.video_schacht_datum_strp = [a for a,b,c in video_schacht_zip]
            #self.video_schacht_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_schacht_zip]
            self.video_schacht_datum = [a.toString("dd.MM.yyyy") for a,b,c in video_schacht_zip]
            self.video_schacht_pfad = [c for a,b,c in video_schacht_zip]

            if len(self.protokoll_pfad) == 0 and len(self.video_schacht_pfad) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu diesem Schacht wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_protokoll.clear()
            self.txt_protokoll_anzahl.setText("")
            if len(self.protokoll_pfad) != 0:
                protokoll_pfad_short = [os.path.basename(f) for f in self.protokoll_pfad]
                protokoll_list = [list(i) for i in zip(self.protokoll_datum,protokoll_pfad_short)]
                protokoll_list = [":  ".join(i) for i in protokoll_list]
                self.combobox_protokoll.addItems(protokoll_list)
                self.txt_protokoll_anzahl.setText(str(len(self.protokoll_pfad)))
                self.button_protokoll.setEnabled(True)
            else:
                self.button_protokoll.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video_schacht.clear()
            self.txt_video_schacht_anzahl.setText("")
            if len(self.video_schacht_pfad) != 0:
                video_schacht_pfad_short = [os.path.basename(f) for f in self.video_schacht_pfad]
                video_schacht_list = [list(i) for i in zip(self.video_schacht_datum, video_schacht_pfad_short)]
                video_schacht_list = [":   ".join(i) for i in video_schacht_list]
                self.combobox_video_schacht.addItems(video_schacht_list)
                self.txt_video_schacht_anzahl.setText(str(len(self.video_schacht_pfad)))
                self.button_video_schacht.setEnabled(True)
            else:
                self.button_video_schacht.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_schacht_pfad) != 0 and len(self.protokoll_pfad) != 0:
                self.button_schacht_alles.setEnabled(True)
            else:
                self.button_schacht_alles.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Schacht {self.txt_schachtNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)
        
        elif object_type == "Leitung":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_leitung"], "Protokolle_Leitung", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_leitungNr.text()}')")

            self.tv_pfad_leitung = []
            self.tv_datum_leitung = []
                
            self.video_pfad_leitung = []
            self.video_datum_leitung = []
                
            self.druck_pfad_leitung = []
            self.druck_datum_leitung = []

            for feature in protokolle.getFeatures():
                if "protokoll" in feature.attribute("bez"):
                    self.tv_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.tv_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.tv_datum_leitung.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.video_datum_leitung.append("1900-01-01 00:00:00")
                elif "druck" in feature.attribute("bez"):
                    self.druck_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.druck_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.druck_datum_leitung.append("1900-01-01 00:00:00")
            
            self.tv_datum_leitung_strp = self.tv_datum_leitung
            self.video_datum_leitung_strp = self.video_datum_leitung
            self.druck_datum_leitung_strp = self.druck_datum_leitung

            tv_zip_leitung = sorted(zip(self.tv_datum_leitung_strp,self.tv_datum_leitung,self.tv_pfad_leitung), reverse = True)
            self.tv_datum_leitung_strp = [a for a,b,c in tv_zip_leitung]
            #self.tv_datum = [a.strftime("%d.%m.%Y") for a,b,c in tv_zip]
            self.tv_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in tv_zip_leitung]
            self.tv_pfad_leitung = [c for a,b,c in tv_zip_leitung]

            video_zip_leitung = sorted(zip(self.video_datum_leitung_strp, self.video_datum_leitung, self.video_pfad_leitung), reverse = True)
            self.video_datum_leitung_strp = [a for a,b,c in video_zip_leitung]
            #self.video_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_zip]
            self.video_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in video_zip_leitung]
            self.video_pfad_leitung = [c for a,b,c in video_zip_leitung]

            druck_zip_leitung = sorted(zip(self.druck_datum_leitung_strp, self.druck_datum_leitung, self.druck_pfad_leitung), reverse = True)
            self.druck_datum_leitung_strp = [a for a,b,c in druck_zip_leitung]
            #self.druck_datum = [a.strftime("%d.%m.%Y") for a,b,c in druck_zip]
            self.druck_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in druck_zip_leitung]
            self.druck_pfad_leitung = [c for a,b,c in druck_zip_leitung]

            if len(self.tv_pfad_leitung) == 0 and len(self.video_pfad_leitung) == 0 and len(self.druck_pfad_leitung) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu dieser Leitung wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_tv_leitung.clear()
            self.txt_tv_anzahl_leitung.setText("")
            if len(self.tv_pfad_leitung) != 0:
                tv_pfad_short_leitung = [os.path.basename(f) for f in self.tv_pfad_leitung]
                tv_list_leitung = [list(i) for i in zip(self.tv_datum_leitung,tv_pfad_short_leitung)]
                tv_list_leitung = [":  ".join(i) for i in tv_list_leitung]
                self.combobox_tv_leitung.addItems(tv_list_leitung)
                self.txt_tv_anzahl_leitung.setText(str(len(self.tv_pfad_leitung)))
                self.button_tv_leitung.setEnabled(True)
            else:
                self.button_tv_leitung.setEnabled(False)
            # auswahl für druckprüfung einfügen
            self.combobox_druck_leitung.clear()
            self.txt_druck_anzahl_leitung.setText("")
            if len(self.druck_pfad_leitung) != 0:
                druck_pfad_short_leitung = [os.path.basename(f) for f in self.druck_pfad_leitung]
                druck_list = [list(i) for i in zip(self.druck_datum_leitung, druck_pfad_short_leitung)]
                druck_list = [":   ".join(i) for i in druck_list]
                self.combobox_druck_leitung.addItems(druck_list)
                self.txt_druck_anzahl_leitung.setText(str(len(self.druck_pfad_leitung)))
                self.button_druck_leitung.setEnabled(True)
            else:
                self.button_druck_leitung.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video_leitung.clear()
            self.txt_video_anzahl_leitung.setText("")
            if len(self.video_pfad_leitung) != 0:
                video_pfad_short = [os.path.basename(f) for f in self.video_pfad_leitung]
                video_list = [list(i) for i in zip(self.video_datum_leitung, video_pfad_short)]
                video_list = [":   ".join(i) for i in video_list]
                self.combobox_video_leitung.addItems(video_list)
                self.txt_video_anzahl_leitung.setText(str(len(self.video_pfad_leitung)))
                self.button_video_leitung.setEnabled(True)
            else:
                self.button_video_leitung.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_pfad_leitung) != 0 and len(self.tv_pfad_leitung) != 0:
                self.button_tv_video_leitung.setEnabled(True)
            else:
                self.button_tv_video_leitung.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Leitung {self.txt_haltungNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)

    def open_file(self,file1, file2 = None, file3 = None):
        if file1 != None:
            try:
                os.startfile(file1)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file1}</b><br>konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")
        if file2 != None:
            try:
                os.startfile(file2)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file2}</b><br> konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")
        if file3 != None:
            try:
                os.startfile(file3)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file3}</b><br>konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")


    def change_col_ergebnisDP(self, object_type):
        txt = self.setup_dict[object_type]["ui"]["txt_ergebnisDP"].text().lower()
        if "undicht" in txt:
            txt.setStyleSheet("QLabel {background-color: #ff3030;}")
        elif "dicht" in txt:
            txt.setStyleSheet("QLabel {background-color: #aaff00;}")
        elif "keine" in txt or "nicht" in txt:
            txt.setStyleSheet("QLabel {background-color: orange;}")
        else:
            self.setup_dict[object_type]["ui"]["txt_ergebnisDP"].setStyleSheet("")