# -*- coding: utf-8 -*-
"""
/***************************************************************************
 KanalManagementDockWidget
                                 A QGIS plugin
 Werkzeuge rund um das Kanalmanagement
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-10
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Armin Matzl
        email                : arminmatzl@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math
import sqlite3
import pandas as pd
import json
from datetime import datetime
from qgis.PyQt.QtCore import Qt, QRegExp, QLine, pyqtSignal, QSignalBlocker, QVariant, QDateTime
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtGui import  QRegExpValidator
from qgis.utils import iface
from qgis.gui import QgsMessageBar, QgsMapToolIdentifyFeature, QgsMapToolPan, QgsSpinBox
from qgis.core import QgsVectorLayer, QgsMessageLog, QgsGeometry, Qgis, QgsProject, QgsFeature,QgsPoint, edit,QgsExpressionContextUtils
from qgis.PyQt.QtWidgets import (QMessageBox, QCompleter, QDialog, QGridLayout, QLabel, QComboBox,
                                QDialogButtonBox,QTableWidgetItem, QTableWidget,
                                QLineEdit, QStyledItemDelegate, QListWidget, QListWidgetItem, QCheckBox,
                                QHBoxLayout, QPushButton)


# eigene klassen
from ..tools.mapIdentify import selectTool
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'protokolle_oeffnen.ui'))


class KanalProtokolleOeffnen(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    load_haltung = pyqtSignal()
    load_schacht = pyqtSignal()
    #load_leitung = pyqtSignal()

    def __init__(self,iface, parent=None):
        """Constructor."""
        super(KanalProtokolleOeffnen, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setCursor(Qt.WaitCursor)
        self.iface = iface
        self.setupUi(self)
        #self.txt_haltungID.setVisible(False) # Textfeld mit HaltungsID verbergen
        self.load_attribute_names_to_dict()
        self.haltungNr_add_completer()
        self.schachtNr_add_completer()

        
      

        #connectors definieren
        self.button_select_haltung.clicked.connect(lambda: self.select_object(self.layer_object["haltung"],self.variablen["attribut_haltungNr"], "Haltung"))
        self.txt_haltungNr.returnPressed.connect(lambda: self.load_layer_from_textField("Haltung"))
        self.txt_haltungNr.textEdited.connect(self.change_col_haltungNr)

        self.button_select_schacht.clicked.connect(lambda: self.select_object(self.layer_object["schacht"],self.variablen["attribut_schachtNr"],"Schacht"))
        self.txt_schachtNr.returnPressed.connect(lambda: self.load_layer_from_textField("Schacht"))
        self.txt_schachtNr.textEdited.connect(self.change_col_schachtNr)

        self.button_tv.clicked.connect(lambda: self.open_file(self.tv_pfad[self.combobox_tv.currentIndex()]))
        self.button_druck.clicked.connect(lambda: self.open_file(self.druck_pfad[self.combobox_druck.currentIndex()]))
        self.button_video.clicked.connect(lambda: self.open_file(self.video_pfad[self.combobox_video.currentIndex()]))
        self.button_tv_video.clicked.connect(lambda: self.open_file(self.tv_pfad[self.combobox_tv.currentIndex()],self.video_pfad[self.combobox_video.currentIndex()]))
        self.button_zoom_haltung.clicked.connect(lambda: self.zoom_to_object(self.layer_object["haltung"], self.features["haltung"].id()))
        
        self.button_protokoll.clicked.connect(lambda: self.open_file(self.protokoll_pfad[self.combobox_protokoll.currentIndex()]))
        self.button_video_schacht.clicked.connect(lambda: self.open_file(self.video_schacht_pfad[self.combobox_video_schacht.currentIndex()]))
        self.button_schacht_alles.clicked.connect(lambda: self.open_file(self.protokoll_pfad[self.combobox_protokoll.currentIndex()],self.video_schacht_pfad[self.combobox_video_schacht.currentIndex()]))
        self.button_zoom_schacht.clicked.connect(lambda: self.zoom_to_object(self.layer_object["schacht"], self.features["schacht"].id()))

        #wenn leitung definiert dann leitung initialisieren
        if self.leitung_defined:
            self.leitungNr_add_completer()

            self.button_select_leitung.clicked.connect(lambda: self.select_object(self.layer_object["leitung"],self.variablen["attribut_leitungNr"], "Leitung"))
            self.txt_leitungNr.returnPressed.connect(lambda: self.load_layer_from_textField("Leitung"))
            self.txt_leitungNr.textEdited.connect(self.change_col_leitungNr)

            self.button_tv_leitung.clicked.connect(lambda: self.open_file(self.tv_pfad_leitung[self.combobox_tv_leitung.currentIndex()]))
            self.button_druck_leitung.clicked.connect(lambda: self.open_file(self.druck_pfad_leitung[self.combobox_druck_leitung.currentIndex()]))
            self.button_video_leitung.clicked.connect(lambda: self.open_file(self.video_pfad_leitung[self.combobox_video_leitung.currentIndex()]))
            self.button_tv_video_leitung.clicked.connect(lambda: self.open_file(self.tv_pfad_leitung[self.combobox_tv_leitung.currentIndex()],self.video_pfad_leitung[self.combobox_video_leitung.currentIndex()]))
            self.button_zoom_leitung.clicked.connect(lambda: self.zoom_to_object(self.layer_object["leitung"], self.features["leitung"].id()))
        else:
            self.tabWidget.removeTab(2)
        
        self.tabWidget.currentChanged.connect(self.tab_changed)
        
        self.setCursor(Qt.ArrowCursor)

   
    def tab_changed(self,tab_nr):
        try:
            tool = self.iface.mapCanvas().mapTool().toolName()

            if tool == "Kanalmanagement Objekt abfragen":
                if tab_nr == 0:
                    self.select_object(self.layer_object["haltung"],self.variablen["attribut_haltungNr"], "Haltung")
                elif tab_nr == 1:
                    self.select_object(self.layer_object["schacht"],self.variablen["attribut_schachtNr"], "Schacht")
                elif tab_nr == 2:
                    self.select_object(self.layer_object["leitung"],self.variablen["attribut_leitungNr"], "Leitung")
        except:
            pass
        
    def closeEvent(self, event):
        """
        Wird bei beenden des Fenserts ausgeführt
        """
        self.closingPlugin.emit()
        event.accept()
        panTool = QgsMapToolPan(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(panTool)
        self.deleteLater()


    def haltungNr_add_completer(self):
        """
        Fügt einen Completer für QLineEdit der Haltungsnummer für manuelle Eingabe ein
        """
        haltungNr_idx = self.layer_object["haltung"].fields().indexOf(self.variablen["attribut_haltungNr"])
        haltungen = sorted(self.layer_object["haltung"].uniqueValues(haltungNr_idx))
        haltungen = [element for element in haltungen if not isinstance(element,QVariant)]
        completer = QCompleter(haltungen)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.txt_haltungNr.setCompleter(completer)

    def schachtNr_add_completer(self):
        """
        Fügt einen Completer für QLineEdit der Schachtnummer für manuelle Eingabe ein
        """
        schachtNr_idx = self.layer_object["schacht"].fields().indexOf(self.variablen["attribut_schachtNr"])
        schacht = sorted(self.layer_object["schacht"].uniqueValues(schachtNr_idx))
        schacht = [element for element in schacht if not isinstance(element,QVariant)]
        completer = QCompleter(schacht)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.txt_schachtNr.setCompleter(completer)
    
    def leitungNr_add_completer(self):
        """
        Fügt einen Completer für QLineEdit der Leitungsnummer für manuelle Eingabe ein
        """
        leitungNr_idx = self.layer_object["leitung"].fields().indexOf(self.variablen["attribut_leitungNr"])
        leitungen = sorted(self.layer_object["leitung"].uniqueValues(leitungNr_idx))
        leitungen = [element for element in leitungen if not isinstance(element,QVariant)]
        completer = QCompleter(leitungen)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.txt_leitungNr.setCompleter(completer)

    def load_attribute_names_to_dict(self):
        """
        Definiert dictionaries mit allen nötigen attributbezeichnungen
        """
        self.setup_dict = json.loads(QgsExpressionContextUtils.projectScope(QgsProject.instance()).variable('Kanalmanagement_Setup'))
        allg_dict = self.setup_dict["allg_einstellungen"]
        protokolle_dict = self.setup_dict["protokolle_setup"]
        self.variablen = {}
        self.variablen["db_kanal_path"] = allg_dict["db_kanal_path"]
        self.variablen["db_sanierung_path"] = self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"]
        self.variablen["db_protokolle"] = protokolle_dict["db_protokolle_path"]
        self.variablen["layer_haltung"] = "KaHaltung"
        self.variablen["layer_schacht"] = "KaSchacht"
        self.variablen["layer_leitung"] = "KaLeitung"
        self.variablen["attribut_haltungNr"] = "HaltungNr"
        self.variablen["attribut_schachtNr"] = "SchachtNr"
        self.variablen["attribut_leitungNr"] = "LeitungNr"
        self.variablen["layer_haltung_name"] = "Haltung"
        self.variablen["layer_protokolle_haltung"] = "Inspektionsdaten_Haltung"
        self.variablen["layer_protokolle_schacht"] = "Inspektionsdaten_Schacht"
        self.variablen["layer_protokolle_leitung"] = "Inspektionsdaten_Haltung"
        self.variablen["attribut_ergebnisDP"] = "ErgebnisDP"
        self.variablen["attribut_zustandsklasse"] = "Haltungsklasse"
        self.variablen["attribut_zustandsklasse_schacht"] = "Schachtklasse"
        self.variablen["attribut_aktuellstesUdatum"] = "AktuellstesUDatum"

        # muss noch verbessert werden, sodass der layer eindeutig ist
        self.layer_object = {}
        #self.layer_object["haltung"] = QgsProject.instance().mapLayersByName(self.variablen["layer_haltung_name"])[0]
        self.layer_object["haltung"] = QgsProject.instance().mapLayer(allg_dict["Haltung_layer_id"])
        self.layer_object["schacht"] = QgsProject.instance().mapLayer(allg_dict["Schacht_layer_id"])
        #leitung kann aber muss nicht definiert sein
        try:
            self.layer_object["leitung"] = QgsProject.instance().mapLayer(allg_dict["Leitung_layer_id"])
            self.leitung_defined = True
        except:
            self.leitung_defined = False

        #dict in das features gespeichert werden
        self.features = {}

    def select_object(self, selection_layer, name_shown, object_type):
        """
        Aktion zum Wählen einer Haltung
        """
        self.selection = selectTool(iface = self.iface,
                                    name_shown = name_shown, #Attribut das in Auswahl angezeigt wird
                                    selection_layer = selection_layer
                                    )
        #self.selection.featureIdentified.connect(self.con)
        self.selection.objectFound.connect(lambda feature, object_type = object_type: self.feature_selected(feature, object_type))
        self.iface.mapCanvas().setMapTool(self.selection)

        #self.identify = QgsMapToolIdentifyFeature(self.iface.mapCanvas(), self.layer_object["haltung"])
        #self.identify.featureIdentified.connect(self.con)
        
        #self.iface.mapCanvas().setMapTool(self.identify)
    
    def feature_selected(self,feature, object_type):
        if object_type == "Haltung":
            self.features["haltung"] = feature
        elif object_type == "Schacht":
            self.features["schacht"] = feature
        elif object_type == "Leitung":
            self.features["leitung"] = feature
        self.load_layer(object_type = object_type)
    
    def change_col_haltungNr(self,text,valid=None):
        if valid != None:
            self.txt_haltungNr.setStyleSheet("")
            self.button_zoom_haltung.setEnabled(True)
        else:
            self.txt_haltungNr.setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.button_zoom_haltung.setEnabled(False)
        
    def change_col_schachtNr(self,text,valid=None):
        if valid != None:
            self.txt_schachtNr.setStyleSheet("")
            self.button_zoom_schacht.setEnabled(True)
        else:
            self.txt_schachtNr.setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.button_zoom_schacht.setEnabled(False)
    
    def change_col_leitungNr(self,text,valid=None):
        if valid != None:
            self.txt_leitungNr.setStyleSheet("")
            self.button_zoom_leitung.setEnabled(True)
        else:
            self.txt_leitungNr.setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.button_zoom_leitung.setEnabled(False)
        
    def load_layer_from_textField(self, object_type):
        self.setCursor(Qt.WaitCursor)
        if object_type == "Haltung":
            filter = self.layer_object["haltung"].subsetString()
            self.layer_object["haltung"].setSubsetString(f"{self.variablen['attribut_haltungNr']}='{self.txt_haltungNr.text()}'")
            print(self.layer_object["haltung"].subsetString())
            if self.layer_object["haltung"].featureCount() == 1:
                haltung_feature = QgsFeature()
                self.layer_object["haltung"].getFeatures().nextFeature(haltung_feature)
                self.features["haltung"] = haltung_feature
                self.load_layer(load_from_txt_field = True, object_type = object_type)
                self.change_col_haltungNr(text = "", valid = True)
                #self.txt_haltungNr.setText(self.features["haltung"].attribut(self.variablen["attribut_haltungNr"]))
            else:
                self.clear_all()
                self.iface.messageBar().pushMessage("Haltung nicht gefunden.", "Die angegebene Haltungsnummer ist ungültig.", level=Qgis.Warning, duration=2)
                self.button_zoom_haltung.setEnabled(False)
            self.layer_object["haltung"].setSubsetString(filter)
        elif object_type == "Schacht":
            filter = self.layer_object["schacht"].subsetString()
            self.layer_object["schacht"].setSubsetString(f"{self.variablen['attribut_schachtNr']}='{self.txt_schachtNr.text()}'")
            if self.layer_object["schacht"].featureCount() == 1:
                schacht_feature = QgsFeature()
                self.layer_object["schacht"].getFeatures().nextFeature(schacht_feature)
                self.features["schacht"] = schacht_feature
                self.load_layer(load_from_txt_field = True, object_type = object_type)
                self.change_col_schachtNr(text = "", valid = True)
            else:
                self.clear_all()
                self.iface.messageBar().pushMessage("Schacht nicht gefunden.", "Die angegebene Schachtnummer ist ungültig.", level=Qgis.Warning, duration=2)
                self.button_zoom_schacht.setEnabled(False)
            self.layer_object["schacht"].setSubsetString(filter)
        elif object_type == "Leitung":
            filter = self.layer_object["leitung"].subsetString()
            self.layer_object["leitung"].setSubsetString(f"{self.variablen['attribut_leitungNr']}='{self.txt_leitungNr.text()}'")
            if self.layer_object["leitung"].featureCount() == 1:
                leitung_feature = QgsFeature()
                self.layer_object["leitung"].getFeatures().nextFeature(leitung_feature)
                self.features["leitung"] = leitung_feature
                self.load_layer(load_from_txt_field = True, object_type = object_type)
                self.change_col_leitungNr(text = "", valid = True)
            else:
                self.clear_all()
                self.iface.messageBar().pushMessage("Leitung nicht gefunden.", "Die angegebene Leitungsnummer ist ungültig.", level=Qgis.Warning, duration=2)
                self.button_zoom_leitung.setEnabled(False)
            self.layer_object["leitung"].setSubsetString(filter)

        self.setCursor(Qt.ArrowCursor)

    def load_layer(self, object_type, load_from_txt_field = False):
        if object_type == "Haltung":            
            if not load_from_txt_field:
                self.txt_haltungNr.setText(self.features["haltung"].attribute(self.variablen["attribut_haltungNr"]))
            self.change_col_haltungNr(text = "", valid = True)        
            
            try:
                ergebnisDP = str(self.features["haltung"].attribute(self.variablen["attribut_ergebnisDP"]))
            except:
                ergebnisDP = 'NULL'
            if ergebnisDP == "NULL":
                ergebnisDP = "keine DP"
            self.txt_ergebnisDP.setText(ergebnisDP)
            self.change_col_ergebnisDP()

            zustandsklasse = str(self.features["haltung"].attribute(self.variablen["attribut_zustandsklasse"]))
            if zustandsklasse == "NULL":
                zustandsklasse = "-"
            self.load_haltung.emit()
        elif object_type == "Schacht":
            if not load_from_txt_field:
                self.txt_schachtNr.setText(self.features["schacht"].attribute(self.variablen["attribut_schachtNr"]))
            self.change_col_schachtNr(text = "", valid = True)        

            zustandsklasse = str(self.features["schacht"].attribute(self.variablen["attribut_zustandsklasse_schacht"]))
            if zustandsklasse == "NULL":
                zustandsklasse = "-"
            self.load_schacht.emit()
        if object_type == "Leitung":            
            if not load_from_txt_field:
                self.txt_leitungNr.setText(self.features["leitung"].attribute(self.variablen["attribut_leitungNr"]))
            self.change_col_leitungNr(text = "", valid = True)        
            
            try:
                ergebnisDP = str(self.features["leitung"].attribute(self.variablen["attribut_ergebnisDP"]))
            except:
                ergebnisDP = 'NULL'
            if ergebnisDP == "NULL":
                ergebnisDP = "keine DP"
            self.txt_ergebnisDP_leitung.setText(ergebnisDP)
            self.change_col_ergebnisDP_leitung()

            #self.load_leitung.emit()

        """self.txt_zustandsklasse.setText(zustandsklasse)
        self.Udatum = self.features["haltung"].attribute(self.variablen["attribut_aktuellstesUdatum"])
        try:
            self.Udatum = self.Udatum.toString("dd.MM.yyyy")
        except:
            self.Udatum = "-"
        self.txt_aktuellstesUdatum.setText(self.Udatum)
        """
        
        self.load_protokolle(object_type)
        
  
    def clear_all(self):
        # Haltung Tab
        self.combobox_tv.clear()
        self.combobox_druck.clear()
        self.combobox_video.clear()

        self.txt_tv_anzahl.setText("")
        self.txt_druck_anzahl.setText("")
        self.txt_video_anzahl.setText("")

        self.button_tv.setEnabled(False)
        self.button_druck.setEnabled(False)
        self.button_video.setEnabled(False)
        self.button_tv_video.setEnabled(False)

        # Schacht Tab
        self.combobox_protokoll.clear()
        self.combobox_video_schacht.clear()

        self.txt_protokoll_anzahl.setText("")
        self.txt_video_schacht_anzahl.setText("")

        self.button_protokoll.setEnabled(False)
        self.button_video_schacht.setEnabled(False)
        self.button_schacht_alles.setEnabled(False)

        #Leitung Tab wenn definiert
        if self.leitung_defined:
            self.combobox_tv_leitung.clear()
            self.combobox_druck_leitung.clear()
            self.combobox_video_leitung.clear()

            self.txt_tv_anzahl_leitung.setText("")
            self.txt_druck_anzahl_leitung.setText("")
            self.txt_video_anzahl_leitung.setText("")

            self.button_tv_leitung.setEnabled(False)
            self.button_druck_leitung.setEnabled(False)
            self.button_video_leitung.setEnabled(False)
            self.button_tv_video_leitung.setEnabled(False)
 
    def zoom_to_object(self,layer, id):
        layer.selectByIds([id], QgsVectorLayer.SetSelection)
        bbox = layer.boundingBoxOfSelected()
        self.iface.mapCanvas().setExtent(bbox)
        scale = self.setup_dict["allg_einstellungen"]["zoom_massstab"]
        self.iface.mapCanvas().zoomScale(scale)
        self.iface.mapCanvas().refresh()

    def load_protokolle(self, object_type):
        if object_type == "Haltung":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_haltung"], "Protokolle_Haltung", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_haltungNr.text()}')")

            self.tv_pfad = []
            self.tv_datum = []
                
            self.video_pfad = []
            self.video_datum = []
                
            self.druck_pfad = []
            self.druck_datum = []

            for feature in protokolle.getFeatures():
                if "protokoll" in feature.attribute("bez"):
                    self.tv_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.tv_datum.append(feature.attribute("datum"))
                    else:
                        self.tv_datum.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_datum.append(feature.attribute("datum"))
                    else:
                        self.video_datum.append("1900-01-01 00:00:00")
                elif "druck" in feature.attribute("bez"):
                    self.druck_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.druck_datum.append(feature.attribute("datum"))
                    else:
                        self.druck_datum.append("1900-01-01 00:00:00")

            """self.tv_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.tv_datum]
            self.video_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.video_datum]
            self.druck_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.druck_datum]"""
            
            self.tv_datum_strp = self.tv_datum
            self.video_datum_strp = self.video_datum
            self.druck_datum_strp = self.druck_datum

            tv_zip = sorted(zip(self.tv_datum_strp,self.tv_datum,self.tv_pfad), reverse = True)
            self.tv_datum_strp = [a for a,b,c in tv_zip]
            #self.tv_datum = [a.strftime("%d.%m.%Y") for a,b,c in tv_zip]
            self.tv_datum = [a.toString("dd.MM.yyyy") for a,b,c in tv_zip]
            self.tv_pfad = [c for a,b,c in tv_zip]

            video_zip = sorted(zip(self.video_datum_strp, self.video_datum, self.video_pfad), reverse = True)
            self.video_datum_strp = [a for a,b,c in video_zip]
            #self.video_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_zip]
            self.video_datum = [a.toString("dd.MM.yyyy") for a,b,c in video_zip]
            self.video_pfad = [c for a,b,c in video_zip]

            druck_zip = sorted(zip(self.druck_datum_strp, self.druck_datum, self.druck_pfad), reverse = True)
            self.druck_datum_strp = [a for a,b,c in druck_zip]
            #self.druck_datum = [a.strftime("%d.%m.%Y") for a,b,c in druck_zip]
            self.druck_datum = [a.toString("dd.MM.yyyy") for a,b,c in druck_zip]
            self.druck_pfad = [c for a,b,c in druck_zip]

            if len(self.tv_pfad) == 0 and len(self.video_pfad) == 0 and len(self.druck_pfad) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu dieser Haltung wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_tv.clear()
            self.txt_tv_anzahl.setText("")
            if len(self.tv_pfad) != 0:
                tv_pfad_short = [os.path.basename(f) for f in self.tv_pfad]
                tv_list = [list(i) for i in zip(self.tv_datum,tv_pfad_short)]
                tv_list = [":  ".join(i) for i in tv_list]
                self.combobox_tv.addItems(tv_list)
                self.txt_tv_anzahl.setText(str(len(self.tv_pfad)))
                self.button_tv.setEnabled(True)
            else:
                self.button_tv.setEnabled(False)
            # auswahl für druckprüfung einfügen
            self.combobox_druck.clear()
            self.txt_druck_anzahl.setText("")
            if len(self.druck_pfad) != 0:
                druck_pfad_short = [os.path.basename(f) for f in self.druck_pfad]
                druck_list = [list(i) for i in zip(self.druck_datum, druck_pfad_short)]
                druck_list = [":   ".join(i) for i in druck_list]
                self.combobox_druck.addItems(druck_list)
                self.txt_druck_anzahl.setText(str(len(self.druck_pfad)))
                self.button_druck.setEnabled(True)
            else:
                self.button_druck.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video.clear()
            self.txt_video_anzahl.setText("")
            if len(self.video_pfad) != 0:
                video_pfad_short = [os.path.basename(f) for f in self.video_pfad]
                video_list = [list(i) for i in zip(self.video_datum, video_pfad_short)]
                video_list = [":   ".join(i) for i in video_list]
                self.combobox_video.addItems(video_list)
                self.txt_video_anzahl.setText(str(len(self.video_pfad)))
                self.button_video.setEnabled(True)
            else:
                self.button_video.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_pfad) != 0 and len(self.tv_pfad) != 0:
                self.button_tv_video.setEnabled(True)
            else:
                self.button_tv_video.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Haltung {self.txt_haltungNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)
        elif object_type == "Schacht":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_schacht"], "Protokolle_Schacht", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_schachtNr.text()}')")

            self.protokoll_pfad = []
            self.protokoll_datum = []
                
            self.video_schacht_pfad = []
            self.video_schacht_datum = []

            for feature in protokolle.getFeatures():
                if feature.attribute("bez") in ["protokoll", "erhebungsblatt", "aufmaßblatt", "aufmassblatt"]:
                    self.protokoll_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.protokoll_datum.append(feature.attribute("datum"))
                    else:
                        self.protokoll_datum.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_schacht_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_schacht_datum.append(feature.attribute("datum"))
                    else:
                        self.video_schacht_datum.append("1900-01-01 00:00:00")


            #self.protokoll_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.protokoll_datum] # alt weil früher als string gespeichert
            self.protokoll_datum_strp = self.protokoll_datum
            #self.video_schacht_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.video_schacht_datum]# alt weil früher als string gespeichert
            self.video_schacht_datum_strp = self.video_schacht_datum

            protokoll_zip = sorted(zip(self.protokoll_datum_strp,self.protokoll_datum,self.protokoll_pfad), reverse = True)
            self.protokoll_datum_strp = [a for a,b,c in protokoll_zip]
            #self.protokoll_datum = [a.strftime("%d.%m.%Y") for a,b,c in protokoll_zip]
            self.protokoll_datum = [a.toString("dd.MM.yyyy") for a,b,c in protokoll_zip]
            self.protokoll_pfad = [c for a,b,c in protokoll_zip]

            video_schacht_zip = sorted(zip(self.video_schacht_datum_strp, self.video_schacht_datum, self.video_schacht_pfad), reverse = True)
            self.video_schacht_datum_strp = [a for a,b,c in video_schacht_zip]
            #self.video_schacht_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_schacht_zip]
            self.video_schacht_datum = [a.toString("dd.MM.yyyy") for a,b,c in video_schacht_zip]
            self.video_schacht_pfad = [c for a,b,c in video_schacht_zip]

            if len(self.protokoll_pfad) == 0 and len(self.video_schacht_pfad) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu diesem Schacht wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_protokoll.clear()
            self.txt_protokoll_anzahl.setText("")
            if len(self.protokoll_pfad) != 0:
                protokoll_pfad_short = [os.path.basename(f) for f in self.protokoll_pfad]
                protokoll_list = [list(i) for i in zip(self.protokoll_datum,protokoll_pfad_short)]
                protokoll_list = [":  ".join(i) for i in protokoll_list]
                self.combobox_protokoll.addItems(protokoll_list)
                self.txt_protokoll_anzahl.setText(str(len(self.protokoll_pfad)))
                self.button_protokoll.setEnabled(True)
            else:
                self.button_protokoll.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video_schacht.clear()
            self.txt_video_schacht_anzahl.setText("")
            if len(self.video_schacht_pfad) != 0:
                video_schacht_pfad_short = [os.path.basename(f) for f in self.video_schacht_pfad]
                video_schacht_list = [list(i) for i in zip(self.video_schacht_datum, video_schacht_pfad_short)]
                video_schacht_list = [":   ".join(i) for i in video_schacht_list]
                self.combobox_video_schacht.addItems(video_schacht_list)
                self.txt_video_schacht_anzahl.setText(str(len(self.video_schacht_pfad)))
                self.button_video_schacht.setEnabled(True)
            else:
                self.button_video_schacht.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_schacht_pfad) != 0 and len(self.protokoll_pfad) != 0:
                self.button_schacht_alles.setEnabled(True)
            else:
                self.button_schacht_alles.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Schacht {self.txt_schachtNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)
        
        elif object_type == "Leitung":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_leitung"], "Protokolle_Leitung", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_leitungNr.text()}')")

            self.tv_pfad_leitung = []
            self.tv_datum_leitung = []
                
            self.video_pfad_leitung = []
            self.video_datum_leitung = []
                
            self.druck_pfad_leitung = []
            self.druck_datum_leitung = []

            for feature in protokolle.getFeatures():
                if "protokoll" in feature.attribute("bez"):
                    self.tv_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.tv_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.tv_datum_leitung.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.video_datum_leitung.append("1900-01-01 00:00:00")
                elif "druck" in feature.attribute("bez"):
                    self.druck_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.druck_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.druck_datum_leitung.append("1900-01-01 00:00:00")
            
            self.tv_datum_leitung_strp = self.tv_datum_leitung
            self.video_datum_leitung_strp = self.video_datum_leitung
            self.druck_datum_leitung_strp = self.druck_datum_leitung

            tv_zip_leitung = sorted(zip(self.tv_datum_leitung_strp,self.tv_datum_leitung,self.tv_pfad_leitung), reverse = True)
            self.tv_datum_leitung_strp = [a for a,b,c in tv_zip_leitung]
            #self.tv_datum = [a.strftime("%d.%m.%Y") for a,b,c in tv_zip]
            self.tv_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in tv_zip_leitung]
            self.tv_pfad_leitung = [c for a,b,c in tv_zip_leitung]

            video_zip_leitung = sorted(zip(self.video_datum_leitung_strp, self.video_datum_leitung, self.video_pfad_leitung), reverse = True)
            self.video_datum_leitung_strp = [a for a,b,c in video_zip_leitung]
            #self.video_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_zip]
            self.video_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in video_zip_leitung]
            self.video_pfad_leitung = [c for a,b,c in video_zip_leitung]

            druck_zip_leitung = sorted(zip(self.druck_datum_leitung_strp, self.druck_datum_leitung, self.druck_pfad_leitung), reverse = True)
            self.druck_datum_leitung_strp = [a for a,b,c in druck_zip_leitung]
            #self.druck_datum = [a.strftime("%d.%m.%Y") for a,b,c in druck_zip]
            self.druck_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in druck_zip_leitung]
            self.druck_pfad_leitung = [c for a,b,c in druck_zip_leitung]

            if len(self.tv_pfad_leitung) == 0 and len(self.video_pfad_leitung) == 0 and len(self.druck_pfad_leitung) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu dieser Leitung wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_tv_leitung.clear()
            self.txt_tv_anzahl_leitung.setText("")
            if len(self.tv_pfad_leitung) != 0:
                tv_pfad_short_leitung = [os.path.basename(f) for f in self.tv_pfad_leitung]
                tv_list_leitung = [list(i) for i in zip(self.tv_datum_leitung,tv_pfad_short_leitung)]
                tv_list_leitung = [":  ".join(i) for i in tv_list_leitung]
                self.combobox_tv_leitung.addItems(tv_list_leitung)
                self.txt_tv_anzahl_leitung.setText(str(len(self.tv_pfad_leitung)))
                self.button_tv_leitung.setEnabled(True)
            else:
                self.button_tv_leitung.setEnabled(False)
            # auswahl für druckprüfung einfügen
            self.combobox_druck_leitung.clear()
            self.txt_druck_anzahl_leitung.setText("")
            if len(self.druck_pfad_leitung) != 0:
                druck_pfad_short_leitung = [os.path.basename(f) for f in self.druck_pfad_leitung]
                druck_list = [list(i) for i in zip(self.druck_datum_leitung, druck_pfad_short_leitung)]
                druck_list = [":   ".join(i) for i in druck_list]
                self.combobox_druck_leitung.addItems(druck_list)
                self.txt_druck_anzahl_leitung.setText(str(len(self.druck_pfad_leitung)))
                self.button_druck_leitung.setEnabled(True)
            else:
                self.button_druck_leitung.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video_leitung.clear()
            self.txt_video_anzahl_leitung.setText("")
            if len(self.video_pfad_leitung) != 0:
                video_pfad_short = [os.path.basename(f) for f in self.video_pfad_leitung]
                video_list = [list(i) for i in zip(self.video_datum_leitung, video_pfad_short)]
                video_list = [":   ".join(i) for i in video_list]
                self.combobox_video_leitung.addItems(video_list)
                self.txt_video_anzahl_leitung.setText(str(len(self.video_pfad_leitung)))
                self.button_video_leitung.setEnabled(True)
            else:
                self.button_video_leitung.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_pfad_leitung) != 0 and len(self.tv_pfad_leitung) != 0:
                self.button_tv_video_leitung.setEnabled(True)
            else:
                self.button_tv_video_leitung.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Leitung {self.txt_haltungNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)

    def open_file(self,file1, file2 = None, file3 = None):
        if file1 != None:
            try:
                os.startfile(file1)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file1}</b><br>konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")
        if file2 != None:
            try:
                os.startfile(file2)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file2}</b><br> konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")
        if file3 != None:
            try:
                os.startfile(file3)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file3}</b><br>konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")


    def change_col_ergebnisDP(self):
        if "undicht" in self.txt_ergebnisDP.text():
            self.txt_ergebnisDP.setStyleSheet("QLabel {background-color: #ff3030;}")
        elif "dicht" in self.txt_ergebnisDP.text().lower():
            self.txt_ergebnisDP.setStyleSheet("QLabel {background-color: #aaff00;}")
        elif "keine" in self.txt_ergebnisDP.text() or "nicht" in self.txt_ergebnisDP.text():
            self.txt_ergebnisDP.setStyleSheet("QLabel {background-color: orange;}")
        else:
            self.txt_ergebnisDP.setStyleSheet("")
    
    def change_col_ergebnisDP_leitung(self):
        if "undicht" in self.txt_ergebnisDP_leitung.text():
            self.txt_ergebnisDP_leitung.setStyleSheet("QLabel {background-color: #ff3030;}")
        elif "dicht" in self.txt_ergebnisDP_leitung.text().lower():
            self.txt_ergebnisDP_leitung.setStyleSheet("QLabel {background-color: #aaff00;}")
        elif "keine" in self.txt_ergebnisDP_leitung.text() or "nicht" in self.txt_ergebnisDP_leitung.text():
            self.txt_ergebnisDP_leitung.setStyleSheet("QLabel {background-color: orange;}")
        else:
            self.txt_ergebnisDP_leitung.setStyleSheet("")
    
    def update_attribute_in_layer(self,typ, layer_name, attribute, value):
        """
        Mit dieser Funktion Werden Attribute eines beliebigen layers aktualisiert. Das Feature wird
        auf Basis des aktuellen features in self.features["schacht"] oder self.features["haltung"] identifiziert.
        typ = Haltung oder Schacht
        layer_name = Name des Layers der geändert werden soll
        attribute = zu änderndes Attribut
        value = neuer wert
        """
        fehler = False
        san_db = self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"]
        layer = QgsVectorLayer(san_db + f"|layername={layer_name}", layer_name, "ogr")
        if typ == "Haltung":
            if "haltung" in self.features.keys():
                layer.setSubsetString(f"HaltungNr = '{self.features['haltung'].attribute(self.variablen['attribut_haltungNr'])}'")
                # neues objekt einfügen
                if layer.featureCount() == 0: 
                    feat = QgsFeature()
                    feat.setFields(layer.fields())
                    feat.setAttribute("HaltungNr", self.features['haltung'].attribute(self.variablen['attribut_haltungNr']))
                    feat.setAttribute("Datum_Bearbeitung", QDateTime(datetime.now()))
                    feat.setAttribute(attribute, value)


                    line = list()
                    for vertex in self.features['haltung'].geometry().asMultiPolyline()[0]:
                        line.append(QgsPoint(vertex.x(), vertex.y()))
                    polyline = QgsGeometry.fromPolyline(line) 
                    feat.setGeometry(polyline)

                    with edit(layer):
                        layer.addFeature(feat)
                else:
                    idx = layer.fields().indexOf(attribute)
                    idx_date = layer.fields().indexOf("Datum_Bearbeitung")
                    change_feat = QgsFeature()
                    layer.getFeatures().nextFeature(change_feat)
                    fid =change_feat.id()
                    with edit(layer):
                        layer.changeAttributeValue(fid,idx,value)
                        layer.changeAttributeValue(fid,idx_date,QDateTime(datetime.now()))
            else:
                fehler = True
            self.update_sanierungskonzept_haltung_listWidget()
            try:
                self.layer_object["haltung_sanierungskonzept"].triggerRepaint()
            except:
                pass
        elif typ == "Schacht":
            if "schacht" in self.features.keys():
                layer.setSubsetString(f"SchachtNr = '{self.features['schacht'].attribute(self.variablen['attribut_schachtNr'])}'")
                # neues objekt einfügen
                if layer.featureCount() == 0: 
                    feat = QgsFeature()
                    feat.setFields(layer.fields())
                    feat.setAttribute("SchachtNr", self.features['schacht'].attribute(self.variablen['attribut_schachtNr']))
                    feat.setAttribute("Datum_Bearbeitung", QDateTime(datetime.now()))
                    feat.setAttribute(attribute, value)

                    feat.setGeometry(self.features['schacht'].geometry())
                    #print(self.features['schacht'].attribute("SchachtNr"))
                    with edit(layer):
                        layer.addFeature(feat)
                else:
                    idx = layer.fields().indexOf(attribute)
                    idx_date = layer.fields().indexOf("Datum_Bearbeitung")
                    change_feat = QgsFeature()
                    layer.getFeatures().nextFeature(change_feat)
                    fid =change_feat.id()
                    with edit(layer):
                        layer.changeAttributeValue(fid,idx,value)
                        layer.changeAttributeValue(fid,idx_date,QDateTime(datetime.now()))
            else:
                fehler = True
            self.update_sanierungskonzept_schacht_listWidget()
            try:
                self.layer_object["schacht_sanierungskonzept"].triggerRepaint()
            except:
                pass
        else:
            fehler = True
        if fehler:
            QMessageBox.warning(self,"Fehler!","Objekt konnte nicht erzeugt werden.")


    def setup_sanierungskonzept(self):
        #leitungen werden nicht dargestellt
        self.tab_defined = False
        try:
            self.tabWidget.removeTab(2)
        except:
            pass
        #sep steht als platzhalter für die horizonatle linie
        auswahl_list = ["keine Maßnahme","sep","Sofortmaßnahme","sep",
        "Renovierung kurzfristig","Renovierung mittelfristig", "Renovierung langfristig","sep",
        "Reparatur kurzfristig","Reparatur mittelfristig", "Reparatur langfristig","sep",
        "Neubau kurzfristig","Neubau mittelfristig", "Neubau langfristig","sep",
        "potenzielle Sofortmaßnahme","sep","laufende Bearbeitung","sep", ""]
        self.auswahl_dict = {}
        self.combobox_separator = []
        for i, element in enumerate(auswahl_list):
            if element != "sep":
                self.auswahl_dict[element] = i
            else: 
                self.combobox_separator.append(i)
        
        filter = ["sep","potenzielle Sofortmaßnahme","sep","Sofortmaßnahme","sep","kurzfristig","mittelfristig","langfristig","sep","Renovierung", "Reparatur","Neubau","sep","keine Maßnahme","sep","laufende Bearbeitung"]
        self.combobox_filter_schacht_list =  ["alle Schächte"] + filter
        self.combobox_filter_haltung_list = ["alle Haltungen"] + filter
        
        try:
            self.layer_object["haltung_sanierungskonzept"] = QgsProject.instance().mapLayersByName("Sanierungskonzept_Haltung")[0]
        except:
            pass
        try:
            self.layer_object["schacht_sanierungskonzept"] = QgsProject.instance().mapLayersByName("Sanierungskonzept_Schacht")[0]
        except:
            pass

        self.setup_sanierungskonzept_haltung()
        self.setup_sanierungskonzept_schacht()

        self.setWindowTitle("Sanierungskonzept")

    def setup_sanierungskonzept_haltung(self):
        self.load_haltung.connect(self.update_sanierungskonzept_haltung)
        self.combobox_konzept_haltung = QComboBox()
        self.combobox_konzept_haltung.addItems(self.auswahl_dict.keys())
        
        for sep in self.combobox_separator:    
            self.combobox_konzept_haltung.insertSeparator(sep)

        with QSignalBlocker(self.combobox_konzept_haltung):
            self.combobox_konzept_haltung.setCurrentIndex(-1)
        self.combobox_konzept_haltung.currentIndexChanged.connect(lambda: self.update_attribute_in_layer("Haltung", "Haltung_Sanierungskonzept", "Sanierungskonzept", self.combobox_konzept_haltung.currentText()))
        self.grid_haltung.addWidget(QLabel("Sanierungskonzept:"),5,0,1,2)
        self.grid_haltung.addWidget(self.combobox_konzept_haltung,5,2,1,2)

        """self.txt_konzept_menge_haltung = QLineEdit()
        self.txt_konzept_menge_haltung.setPlaceholderText("Menge")
        reg_ex_menge = QRegExp("^\d{1,3}\.\d{1}|^\d{1,3}")
        input_validator_menge = QRegExpValidator(reg_ex_menge, self.txt_konzept_menge_haltung)
        self.txt_konzept_menge_haltung.setValidator(input_validator_menge)
        self.grid_haltung.addWidget(self.txt_konzept_menge_haltung,5,4,1,2)
        self.txt_konzept_menge_haltung.textEdited.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_menge_haltung, valid = False))
        self.txt_konzept_menge_haltung.editingFinished.connect(lambda: self.update_attribute_in_layer("Haltung", "Haltung_Sanierungskonzept", "Menge", float(self.txt_konzept_menge_haltung.text())))
        self.txt_konzept_menge_haltung.editingFinished.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_menge_haltung, valid = True))"""

        self.txt_konzept_klasse_haltung = QLineEdit()
        self.txt_konzept_klasse_haltung.setPlaceholderText("man. Zustandskl.")
        reg_ex_klasse = QRegExp("^[0-5]$")
        input_validator_klasse = QRegExpValidator(reg_ex_klasse, self.txt_konzept_klasse_haltung)
        self.txt_konzept_klasse_haltung.setValidator(input_validator_klasse)
        self.grid_haltung.addWidget(self.txt_konzept_klasse_haltung,5,4,1,2)
        self.txt_konzept_klasse_haltung.textEdited.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_klasse_haltung, valid = False))
        self.txt_konzept_klasse_haltung.editingFinished.connect(lambda: self.update_attribute_in_layer("Haltung", "Haltung_Sanierungskonzept", "Haltungsklasse_manuell", float(self.txt_konzept_klasse_haltung.text())))
        self.txt_konzept_klasse_haltung.editingFinished.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_klasse_haltung, valid = True))

        hbox = QHBoxLayout()
        self.checkbox_zoom_haltung = QCheckBox()
        self.checkbox_zoom_haltung.setChecked(True)
        hbox.addWidget(self.checkbox_zoom_haltung,0)
        hbox.addWidget(QLabel("  bei Laden zum Objekt Zoomen"),1)
        self.grid_haltung.addLayout(hbox,5,6,1,2)
        
        self.txt_konzept_haltung_kommentar = QLineEdit()
        self.grid_haltung.addWidget(QLabel("Kommentar:"),6,0,1,2)
        self.grid_haltung.addWidget(self.txt_konzept_haltung_kommentar,6,2,1,6)
        self.txt_konzept_haltung_kommentar.textEdited.connect(self.change_col_konzept_haltung_kommentar)
        self.txt_konzept_haltung_kommentar.editingFinished.connect((lambda: self.update_attribute_in_layer("Haltung", "Haltung_Sanierungskonzept", "Kommentar", self.txt_konzept_haltung_kommentar.text())))
        self.txt_konzept_haltung_kommentar.editingFinished.connect(lambda: self.change_col_konzept_haltung_kommentar(text = "", valid = True))

        #self.txt_konzept_menge_haltung.setEnabled(False)
        self.txt_konzept_klasse_haltung.setEnabled(False)
        self.combobox_konzept_haltung.setEnabled(False)
        self.txt_konzept_haltung_kommentar.setEnabled(False)

        self.sanierungskonzept_haltung_list = QListWidget()
        self.grid_haltung.addWidget(self.sanierungskonzept_haltung_list,7,2,4,5)
        self.sanierungskonzept_haltung_list.itemDoubleClicked.connect(self.sanierungskonzept_haltung_item_clicked)

        self.combobox_filter_haltung = QComboBox()
        self.combobox_filter_haltung.setMaximumWidth(150)
        for i, element in enumerate(self.combobox_filter_haltung_list):
            if element != "sep":
                self.combobox_filter_haltung.addItem(element)
            else:
                self.combobox_filter_haltung.insertSeparator(i)
        self.grid_haltung.addWidget(self.combobox_filter_haltung,7,7,1,1)
        self.combobox_filter_haltung.currentIndexChanged.connect(self.update_sanierungskonzept_haltung_listWidget)

        self.button_delete_haltung = QPushButton("Haltung entfernen")
        self.grid_haltung.addWidget(self.button_delete_haltung,8,7,1,1)
        self.button_delete_haltung.clicked.connect(lambda: self.delete_object("Haltung", "Haltung_Sanierungskonzept"))
        
        self.button_load_layer = QPushButton("Layer mit Maßnahmen laden")
        self.grid_haltung.addWidget(self.button_load_layer,9,7,1,1)
        self.button_load_layer.clicked.connect(self.load_massnahmen_layer_to_canvas)
        
        self.update_sanierungskonzept_haltung_listWidget()

    def change_col_konzept_haltung_kommentar(self,text,valid=None):
        if valid != None:
            self.txt_konzept_haltung_kommentar.setStyleSheet("")
        else:
            self.txt_konzept_haltung_kommentar.setStyleSheet("QLineEdit::editable {background-color: orange;}")
    
    def update_sanierungskonzept_haltung(self):
        self.combobox_konzept_haltung.setEnabled(True)
        self.txt_konzept_haltung_kommentar.setEnabled(True)
        #self.txt_konzept_menge_haltung.setEnabled(True)
        self.txt_konzept_klasse_haltung.setEnabled(True)

        con = sqlite3.connect(self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"])
        haltung = pd.read_sql_query(f"SELECT * from Haltung_Sanierungskonzept WHERE HaltungNr = '{self.txt_haltungNr.text()}'",con)
        con.close()

        if len(haltung) > 0:
            with QSignalBlocker(self.txt_konzept_haltung_kommentar):
                self.txt_konzept_haltung_kommentar.setText(haltung.Kommentar.tolist()[0])
            with QSignalBlocker(self.combobox_konzept_haltung):
                if haltung.Sanierungskonzept.tolist()[0] != None:
                    self.combobox_konzept_haltung.setCurrentIndex(self.auswahl_dict[haltung.Sanierungskonzept.tolist()[0]])
                else:
                    self.combobox_konzept_haltung.setCurrentIndex(-1)
            """with QSignalBlocker(self.txt_konzept_menge_haltung):
                if haltung.Menge.tolist()[0] == "" or haltung.Menge.tolist()[0] == None:
                    self.txt_konzept_menge_haltung.setText("")
                else:
                    self.txt_konzept_menge_haltung.setText(str(haltung.Menge.tolist()[0]))"""

            with QSignalBlocker(self.txt_konzept_klasse_haltung):
                if haltung.Haltungsklasse_manuell.tolist()[0] == "" or haltung.Haltungsklasse_manuell.tolist()[0] == None:
                    self.txt_konzept_klasse_haltung.setText("")
                else:
                    self.txt_konzept_klasse_haltung.setText(str(haltung.Haltungsklasse_manuell.tolist()[0]))
        else:
            with QSignalBlocker(self.txt_konzept_haltung_kommentar):
                self.txt_konzept_haltung_kommentar.setText("")
            with QSignalBlocker(self.combobox_konzept_haltung):
                self.combobox_konzept_haltung.setCurrentIndex(-1)
            #with QSignalBlocker(self.txt_konzept_menge_haltung):
            #    self.txt_konzept_menge_haltung.setText("")
            with QSignalBlocker(self.txt_konzept_klasse_haltung):
                self.txt_konzept_klasse_haltung.setText("")
        
    def update_sanierungskonzept_haltung_listWidget(self):
        self.sanierungskonzept_haltung_list.clear()
        sql_query = "SELECT * FROM Haltung_Sanierungskonzept"
        filter = self.combobox_filter_haltung.currentText()
        if filter != "alle Haltungen":
            if filter in ["Sofortmaßnahme","potenzielle Sofortmaßnahme"]:
                sql_query = sql_query + f" WHERE Sanierungskonzept = '{filter}'"
            else:
                sql_query = sql_query + f" WHERE Sanierungskonzept like '%{filter}%'"
        
        con = sqlite3.connect(self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"])
        haltung_df = pd.read_sql_query(sql_query,con)
        con.close()

        for idx, haltung in haltung_df.iterrows():
            txt = f"{haltung.HaltungNr}:"
            if haltung.Sanierungskonzept != "" and haltung.Sanierungskonzept != None:
                txt = f"{txt} {haltung.Sanierungskonzept}"
            if haltung.Kommentar != "" and haltung.Kommentar != None:
                txt = f"{txt} - {haltung.Kommentar}" 
            item = QListWidgetItem(txt)
            item.nr = haltung.HaltungNr
            item.id = haltung.fid
            self.sanierungskonzept_haltung_list.addItem(item)

    def sanierungskonzept_haltung_item_clicked(self,item):
        self.txt_haltungNr.setText(item.nr)
        self.load_layer_from_textField(object_type = "Haltung")
        if self.checkbox_zoom_haltung.isChecked():
            self.zoom_to_object(self.layer_object["haltung"], self.features["haltung"].id())
    
    def setup_sanierungskonzept_schacht(self):
        self.load_schacht.connect(self.update_sanierungskonzept_schacht)
        self.combobox_konzept_schacht = QComboBox()
        self.combobox_konzept_schacht.addItems(self.auswahl_dict.keys())
        for sep in self.combobox_separator:    
            self.combobox_konzept_schacht.insertSeparator(sep)

        with QSignalBlocker(self.combobox_konzept_schacht):
            self.combobox_konzept_schacht.setCurrentIndex(-1)
        self.combobox_konzept_schacht.currentIndexChanged.connect(lambda: self.update_attribute_in_layer("Schacht", "Schacht_Sanierungskonzept", "Sanierungskonzept", self.combobox_konzept_schacht.currentText()))
        self.grid_schacht.addWidget(QLabel("Sanierungskonzept:"),4,0,1,2)
        self.grid_schacht.addWidget(self.combobox_konzept_schacht,4,2,1,1)

        """self.txt_konzept_menge_schacht = QLineEdit()
        self.txt_konzept_menge_schacht.setPlaceholderText("Menge")
        reg_ex_menge = QRegExp("^\d{1,3}\.\d{1}|^\d{1,3}")
        input_validator_menge = QRegExpValidator(reg_ex_menge, self.txt_konzept_menge_schacht)
        self.txt_konzept_menge_schacht.setValidator(input_validator_menge)
        self.grid_schacht.addWidget(self.txt_konzept_menge_schacht,4,3,1,1)
        self.txt_konzept_menge_schacht.textEdited.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_menge_schacht, valid = False))
        self.txt_konzept_menge_schacht.editingFinished.connect(lambda: self.update_attribute_in_layer("Schacht", "Schacht_Sanierungskonzept", "Menge", float(self.txt_konzept_menge_schacht.text())))
        self.txt_konzept_menge_schacht.editingFinished.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_menge_schacht, valid = True))"""

        self.txt_konzept_klasse_schacht = QLineEdit()
        self.txt_konzept_klasse_schacht.setPlaceholderText("man. Zustandskl.")
        reg_ex_klasse = QRegExp("^[0-5]$")
        input_validator_klasse = QRegExpValidator(reg_ex_klasse, self.txt_konzept_klasse_schacht)
        self.txt_konzept_klasse_schacht.setValidator(input_validator_klasse)
        self.grid_schacht.addWidget(self.txt_konzept_klasse_schacht,4,3,1,1)
        self.txt_konzept_klasse_schacht.textEdited.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_klasse_schacht, valid = False))
        self.txt_konzept_klasse_schacht.editingFinished.connect(lambda: self.update_attribute_in_layer("Schacht", "Schacht_Sanierungskonzept", "Schachtklasse_manuell", float(self.txt_konzept_klasse_schacht.text())))
        self.txt_konzept_klasse_schacht.editingFinished.connect(lambda: self.change_col_lineedit(text = "",widget = self.txt_konzept_klasse_schacht, valid = True))

        hbox = QHBoxLayout()
        self.checkbox_zoom_schacht = QCheckBox()
        self.checkbox_zoom_schacht.setChecked(True)
        hbox.addWidget(self.checkbox_zoom_schacht,0)
        hbox.addWidget(QLabel("  bei Laden zum Objekt Zoomen"),1)
        self.grid_schacht.addLayout(hbox,4,4,1,2)

        self.txt_konzept_schacht_kommentar = QLineEdit()
        self.grid_schacht.addWidget(QLabel("Kommentar:"),5,0,1,2)
        self.grid_schacht.addWidget(self.txt_konzept_schacht_kommentar,5,2,1,4)
        self.txt_konzept_schacht_kommentar.textEdited.connect(self.change_col_konzept_schacht_kommentar)
        self.txt_konzept_schacht_kommentar.editingFinished.connect((lambda: self.update_attribute_in_layer("Schacht", "Schacht_Sanierungskonzept", "Kommentar", self.txt_konzept_schacht_kommentar.text())))
        self.txt_konzept_schacht_kommentar.editingFinished.connect(lambda: self.change_col_konzept_schacht_kommentar(text = "", valid = True))

        self.combobox_konzept_schacht.setEnabled(False)
        self.txt_konzept_schacht_kommentar.setEnabled(False)

        self.sanierungskonzept_schacht_list = QListWidget()
        self.grid_schacht.addWidget(self.sanierungskonzept_schacht_list,6,2,3,3)
        self.sanierungskonzept_schacht_list.itemDoubleClicked.connect(self.sanierungskonzept_schacht_item_clicked)

        self.combobox_filter_schacht = QComboBox()
        self.combobox_filter_schacht.setMaximumWidth(150)
        for i, element in enumerate(self.combobox_filter_schacht_list):
            if element != "sep":
                self.combobox_filter_schacht.addItem(element)
            else:
                self.combobox_filter_schacht.insertSeparator(i)
        self.grid_schacht.addWidget(self.combobox_filter_schacht,6,5,1,1)
        self.combobox_filter_schacht.currentIndexChanged.connect(self.update_sanierungskonzept_schacht_listWidget)

        self.button_delete_schacht = QPushButton("Schacht entfernen")
        self.grid_schacht.addWidget(self.button_delete_schacht,7,5,1,1)
        self.button_delete_schacht.clicked.connect(lambda: self.delete_object("Schacht", "Schacht_Sanierungskonzept"))

        self.update_sanierungskonzept_schacht_listWidget()

    def change_col_lineedit(self,text,widget,valid):
        if valid:
            widget.setStyleSheet("")
        else:
            widget.setStyleSheet("QLineEdit::editable {background-color: orange;}")

    def change_col_konzept_schacht_kommentar(self,text,valid=None):
        if valid != None:
            self.txt_konzept_schacht_kommentar.setStyleSheet("")
        else:
            self.txt_konzept_schacht_kommentar.setStyleSheet("QLineEdit::editable {background-color: orange;}")
    
    def update_sanierungskonzept_schacht(self):
        self.combobox_konzept_schacht.setEnabled(True)
        self.txt_konzept_schacht_kommentar.setEnabled(True)
        #self.txt_konzept_menge_schacht.setEnabled(True)
        self.txt_konzept_klasse_schacht.setEnabled(True)

        con = sqlite3.connect(self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"])
        schacht = pd.read_sql_query(f"SELECT * from Schacht_Sanierungskonzept WHERE SchachtNr = '{self.txt_schachtNr.text()}'",con)
        con.close()

        if len(schacht) > 0:
            with QSignalBlocker(self.txt_konzept_schacht_kommentar):
                self.txt_konzept_schacht_kommentar.setText(schacht.Kommentar.tolist()[0])
            with QSignalBlocker(self.combobox_konzept_schacht):
                if schacht.Sanierungskonzept.tolist()[0] != None:
                    self.combobox_konzept_schacht.setCurrentIndex(self.auswahl_dict[schacht.Sanierungskonzept.tolist()[0]])
                else:
                    self.combobox_konzept_schacht.setCurrentIndex(-1)
            """with QSignalBlocker(self.txt_konzept_menge_schacht):
                if schacht.Menge.tolist()[0] == "" or schacht.Menge.tolist()[0] == None:
                    self.txt_konzept_menge_schacht.setText("")
                else:
                    self.txt_konzept_menge_schacht.setText(str(schacht.Menge.tolist()[0]))"""
            with QSignalBlocker(self.txt_konzept_klasse_schacht):
                if schacht.Schachtklasse_manuell.tolist()[0] == "" or schacht.Schachtklasse_manuell.tolist()[0] == None:
                    self.txt_konzept_klasse_schacht.setText("")
                else:
                    self.txt_konzept_klasse_schacht.setText(str(schacht.Schachtklasse_manuell.tolist()[0]))
        else:
            with QSignalBlocker(self.txt_konzept_schacht_kommentar):
                self.txt_konzept_schacht_kommentar.setText("")
            with QSignalBlocker(self.combobox_konzept_schacht):
                self.combobox_konzept_schacht.setCurrentIndex(-1)
            with QSignalBlocker(self.txt_konzept_klasse_schacht):
                self.txt_konzept_klasse_schacht.setText("")
        
    def update_sanierungskonzept_schacht_listWidget(self):
        self.sanierungskonzept_schacht_list.clear()
        sql_query = "SELECT * FROM Schacht_Sanierungskonzept"
        filter = self.combobox_filter_schacht.currentText()
        if filter != "alle Schächte":
            if filter in ["Sofortmaßnahme", "potenzielle Sofortmaßnahme"]:
                sql_query = sql_query + f" WHERE Sanierungskonzept = '{filter}'"
            else:
                sql_query = sql_query + f" WHERE Sanierungskonzept like '%{filter}%'"
        
        con = sqlite3.connect(self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"])
        schacht_df = pd.read_sql_query(sql_query,con)
        con.close()

        for idx, schacht in schacht_df.iterrows():
            txt = f"{schacht.SchachtNr}:"
            if schacht.Sanierungskonzept != "" and schacht.Sanierungskonzept != None:
                txt = f"{txt} {schacht.Sanierungskonzept}"
            if schacht.Kommentar != "" and schacht.Kommentar != None:
                txt = f"{txt} - {schacht.Kommentar}" 
            item = QListWidgetItem(txt)
            item.nr = schacht.SchachtNr
            item.id = schacht.fid
            self.sanierungskonzept_schacht_list.addItem(item)

    def sanierungskonzept_schacht_item_clicked(self,item):
        self.txt_schachtNr.setText(item.nr)
        self.load_layer_from_textField(object_type = "Schacht")
        if self.checkbox_zoom_schacht.isChecked():
            self.zoom_to_object(self.layer_object["schacht"], self.features["schacht"].id())

    def delete_object(self,typ, layer_name):
        san_db = self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"]
        layer = QgsVectorLayer(san_db + f"|layername={layer_name}", layer_name, "ogr")
        if typ == "Haltung":
            if len(self.sanierungskonzept_haltung_list.selectedItems()) > 0:
                item = self.sanierungskonzept_haltung_list.selectedItems()[0]
                fortfahren =QMessageBox.warning(self,"Haltung entfernen",f"Soll die Haltung <b>{item.nr}</b> aus der Liste entfernt werden?", QMessageBox.Yes|QMessageBox.No)
                if fortfahren == QMessageBox.Yes:
                    with edit(layer):
                        layer.deleteFeature(item.id)
                    self.update_sanierungskonzept_haltung_listWidget()
                    with QSignalBlocker(self.combobox_konzept_haltung):
                        self.combobox_konzept_haltung.setCurrentIndex(-1)
                    with QSignalBlocker(self.txt_konzept_haltung_kommentar):
                        self.txt_konzept_haltung_kommentar.setText("")
            try:
                self.layer_object["haltung_sanierungskonzept"].triggerRepaint()
            except:
                pass
        elif typ == "Schacht":
            if len(self.sanierungskonzept_schacht_list.selectedItems()) > 0:
                item = self.sanierungskonzept_schacht_list.selectedItems()[0]
                fortfahren =QMessageBox.warning(self,"Schacht entfernen",f"Soll der Schacht <b>{item.nr}</b> aus der Liste entfernt werden?", QMessageBox.Yes|QMessageBox.No)
                if fortfahren == QMessageBox.Yes:
                    with edit(layer):
                        layer.deleteFeature(item.id)
                    self.update_sanierungskonzept_schacht_listWidget()
                    with QSignalBlocker(self.combobox_konzept_schacht):
                        self.combobox_konzept_schacht.setCurrentIndex(-1)
                    with QSignalBlocker(self.txt_konzept_schacht_kommentar):
                        self.txt_konzept_schacht_kommentar.setText("")
            try:
                self.layer_object["schacht_sanierungskonzept"].triggerRepaint()
            except:
                pass

    def load_massnahmen_layer_to_canvas(self):
        root = QgsProject.instance().layerTreeRoot()
        if root.findGroup("Sanierungskonzept") == None:
            self.layer_object["haltung_sanierungskonzept"] = QgsVectorLayer(self.variablen["db_sanierung_path"]+"|layername=Haltung_Sanierungskonzept","Sanierungskonzept_Haltung","ogr")
            self.layer_object["schacht_sanierungskonzept"] = QgsVectorLayer(self.variablen["db_sanierung_path"]+"|layername=Schacht_Sanierungskonzept","Sanierungskonzept_Schacht","ogr")
            QgsProject.instance().addMapLayer(self.layer_object["haltung_sanierungskonzept"],False)
            QgsProject.instance().addMapLayer(self.layer_object["schacht_sanierungskonzept"],False)
            qml_haltung = os.path.abspath(os.path.join(os.path.dirname(__file__),"..","Layerstile","Haltung_Sanierungskonzept.qml"))
            qml_schacht = os.path.abspath(os.path.join(os.path.dirname(__file__),"..","Layerstile","Schacht_Sanierungskonzept.qml"))
            self.layer_object["haltung_sanierungskonzept"].loadNamedStyle(qml_haltung)
            self.layer_object["schacht_sanierungskonzept"].loadNamedStyle(qml_schacht)
            
            group = root.insertGroup(0,"Sanierungskonzept")
            group.addLayer(self.layer_object["schacht_sanierungskonzept"])
            group.addLayer(self.layer_object["haltung_sanierungskonzept"])

