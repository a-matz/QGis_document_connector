# -*- coding: utf-8 -*-
"""
/***************************************************************************
 KanalManagementDockWidget
                                 A QGIS plugin
 Werkzeuge rund um das Kanalmanagement
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-10
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Armin Matzl
        email                : arminmatzl@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import math
import sqlite3
import pandas as pd
import json
from datetime import datetime
from qgis.PyQt.QtCore import Qt, QRegExp, QLine, pyqtSignal, QSignalBlocker, QVariant, QDateTime
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtGui import  QRegExpValidator
from qgis.utils import iface
from qgis.gui import QgsMessageBar, QgsMapToolIdentifyFeature, QgsMapToolPan, QgsSpinBox
from qgis.core import QgsVectorLayer, QgsMessageLog, QgsGeometry, Qgis, QgsProject, QgsFeature,QgsPoint, edit,QgsExpressionContextUtils
from qgis.PyQt.QtWidgets import (QMessageBox, QCompleter, QDialog, QGridLayout, QLabel, QComboBox,
                                QDialogButtonBox,QTableWidgetItem, QTableWidget,
                                QLineEdit, QStyledItemDelegate, QListWidget, QListWidgetItem, QCheckBox,
                                QHBoxLayout, QPushButton)


# eigene klassen
from ..tools.mapIdentify import selectTool
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__),"../","ui", 'protokolle_oeffnen.ui'))


class Open(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    load_haltung = pyqtSignal()
    load_schacht = pyqtSignal()
    #load_leitung = pyqtSignal()

    def __init__(self,iface, parent=None):
        """Constructor."""
        super(Open, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setCursor(Qt.WaitCursor)
        self.iface = iface
        self.setupUi(self)
        #self.txt_haltungID.setVisible(False) # Textfeld mit HaltungsID verbergen
        self.load_attribute_names_to_dict()
        self.haltungNr_add_completer()
        self.schachtNr_add_completer()

        #connectors definieren
        self.button_select_haltung.clicked.connect(lambda: self.select_object(self.layer_object["haltung"],self.variablen["attribut_haltungNr"], "Haltung"))
        self.txt_haltungNr.returnPressed.connect(lambda: self.load_layer_from_textField("Haltung"))
        self.txt_haltungNr.textEdited.connect(self.change_col_haltungNr)

        self.button_select_schacht.clicked.connect(lambda: self.select_object(self.layer_object["schacht"],self.variablen["attribut_schachtNr"],"Schacht"))
        self.txt_schachtNr.returnPressed.connect(lambda: self.load_layer_from_textField("Schacht"))
        self.txt_schachtNr.textEdited.connect(self.change_col_schachtNr)

        self.button_h_protokoll.clicked.connect(lambda: self.open_file(self.tv_pfad[self.h_combobox_protokoll.currentIndex()]))
        self.button_h_druck.clicked.connect(lambda: self.open_file(self.druck_pfad[self.h_combobox_druck.currentIndex()]))
        self.button_h_video.clicked.connect(lambda: self.open_file(self.video_pfad[self.h_combobox_video.currentIndex()]))
        self.button_h_protokoll_video.clicked.connect(lambda: self.open_file(self.tv_pfad[self.button_h_protokoll.currentIndex()],self.video_pfad[self.combobox_video.currentIndex()]))
        self.button_zoom_haltung.clicked.connect(lambda: self.zoom_to_object(self.layer_object["haltung"], self.features["haltung"].id()))
        
        self.button_s_protokoll.clicked.connect(lambda: self.open_file(self.protokoll_pfad[self.s_combobox_protokoll.currentIndex()]))
        self.button_s_video_schacht.clicked.connect(lambda: self.open_file(self.video_schacht_pfad[self.s_combobox_video.currentIndex()]))
        self.button_s_protokoll_video.clicked.connect(lambda: self.open_file(self.protokoll_pfad[self.s_combobox_protokoll.currentIndex()],self.video_schacht_pfad[self.s_combobox_video.currentIndex()]))
        self.button_zoom_schacht.clicked.connect(lambda: self.zoom_to_object(self.layer_object["schacht"], self.features["schacht"].id()))

        #wenn leitung definiert dann leitung initialisieren
        if self.leitung_defined:
            self.leitungNr_add_completer()

            self.button_select_leitung.clicked.connect(lambda: self.select_object(self.layer_object["leitung"],self.variablen["attribut_leitungNr"], "Leitung"))
            self.txt_leitungNr.returnPressed.connect(lambda: self.load_layer_from_textField("Leitung"))
            self.txt_leitungNr.textEdited.connect(self.change_col_leitungNr)

            self.button_tv_leitung.clicked.connect(lambda: self.open_file(self.tv_pfad_leitung[self.combobox_tv_leitung.currentIndex()]))
            self.button_druck_leitung.clicked.connect(lambda: self.open_file(self.druck_pfad_leitung[self.combobox_druck_leitung.currentIndex()]))
            self.button_video_leitung.clicked.connect(lambda: self.open_file(self.video_pfad_leitung[self.combobox_video_leitung.currentIndex()]))
            self.button_tv_video_leitung.clicked.connect(lambda: self.open_file(self.tv_pfad_leitung[self.combobox_tv_leitung.currentIndex()],self.video_pfad_leitung[self.combobox_video_leitung.currentIndex()]))
            self.button_zoom_leitung.clicked.connect(lambda: self.zoom_to_object(self.layer_object["leitung"], self.features["leitung"].id()))
        else:
            self.tabWidget.removeTab(2)
        
        self.tabWidget.currentChanged.connect(self.tab_changed)
        
        self.setCursor(Qt.ArrowCursor)

   
    def tab_changed(self,tab_nr):
        try:
            tool = self.iface.mapCanvas().mapTool().toolName()

            if tool == "Kanalmanagement Objekt abfragen":
                if tab_nr == 0:
                    self.select_object(self.layer_object["haltung"],self.variablen["attribut_haltungNr"], "Haltung")
                elif tab_nr == 1:
                    self.select_object(self.layer_object["schacht"],self.variablen["attribut_schachtNr"], "Schacht")
                elif tab_nr == 2:
                    self.select_object(self.layer_object["leitung"],self.variablen["attribut_leitungNr"], "Leitung")
        except:
            pass
        
    def closeEvent(self, event):
        """
        Wird bei beenden des Fenserts ausgeführt
        """
        self.closingPlugin.emit()
        event.accept()
        panTool = QgsMapToolPan(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(panTool)
        self.deleteLater()


    def haltungNr_add_completer(self):
        """
        Fügt einen Completer für QLineEdit der Haltungsnummer für manuelle Eingabe ein
        """
        haltungNr_idx = self.layer_object["haltung"].fields().indexOf(self.variablen["attribut_haltungNr"])
        haltungen = sorted(self.layer_object["haltung"].uniqueValues(haltungNr_idx))
        haltungen = [element for element in haltungen if not isinstance(element,QVariant)]
        completer = QCompleter(haltungen)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.txt_haltungNr.setCompleter(completer)

    def schachtNr_add_completer(self):
        """
        Fügt einen Completer für QLineEdit der Schachtnummer für manuelle Eingabe ein
        """
        schachtNr_idx = self.layer_object["schacht"].fields().indexOf(self.variablen["attribut_schachtNr"])
        schacht = sorted(self.layer_object["schacht"].uniqueValues(schachtNr_idx))
        schacht = [element for element in schacht if not isinstance(element,QVariant)]
        completer = QCompleter(schacht)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.txt_schachtNr.setCompleter(completer)
    
    def leitungNr_add_completer(self):
        """
        Fügt einen Completer für QLineEdit der Leitungsnummer für manuelle Eingabe ein
        """
        leitungNr_idx = self.layer_object["leitung"].fields().indexOf(self.variablen["attribut_leitungNr"])
        leitungen = sorted(self.layer_object["leitung"].uniqueValues(leitungNr_idx))
        leitungen = [element for element in leitungen if not isinstance(element,QVariant)]
        completer = QCompleter(leitungen)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.txt_leitungNr.setCompleter(completer)

    def load_attribute_names_to_dict(self):
        """
        Definiert dictionaries mit allen nötigen attributbezeichnungen
        """
        self.setup_dict = json.loads(QgsExpressionContextUtils.projectScope(QgsProject.instance()).variable('Kanalmanagement_Setup'))
        self.variablen = {}
        self.variablen["db_kanal_path"] = allg_dict["db_kanal_path"]
        self.variablen["db_sanierung_path"] = self.setup_dict["detailsanierungsplanung_setup"]["db_sanierung_path"]
        self.variablen["db_protokolle"] = protokolle_dict["db_protokolle_path"]
        self.variablen["layer_haltung"] = "KaHaltung"
        self.variablen["layer_schacht"] = "KaSchacht"
        self.variablen["layer_leitung"] = "KaLeitung"
        self.variablen["attribut_haltungNr"] = "HaltungNr"
        self.variablen["attribut_schachtNr"] = "SchachtNr"
        self.variablen["attribut_leitungNr"] = "LeitungNr"
        self.variablen["layer_haltung_name"] = "Haltung"
        self.variablen["layer_protokolle_haltung"] = "Inspektionsdaten_Haltung"
        self.variablen["layer_protokolle_schacht"] = "Inspektionsdaten_Schacht"
        self.variablen["layer_protokolle_leitung"] = "Inspektionsdaten_Haltung"
        self.variablen["attribut_ergebnisDP"] = "ErgebnisDP"
        #self.variablen["attribut_zustandsklasse"] = "Haltungsklasse"
        #self.variablen["attribut_zustandsklasse_schacht"] = "Schachtklasse"
        #self.variablen["attribut_aktuellstesUdatum"] = "AktuellstesUDatum"

        # muss noch verbessert werden, sodass der layer eindeutig ist
        self.layer_object = {}
        #self.layer_object["haltung"] = QgsProject.instance().mapLayersByName(self.variablen["layer_haltung_name"])[0]
        self.layer_object["haltung"] = QgsProject.instance().mapLayer(allg_dict["Haltung_layer_id"]).clone()
        self.layer_object["schacht"] = QgsProject.instance().mapLayer(allg_dict["Schacht_layer_id"]).clone()
        #leitung kann aber muss nicht definiert sein
        try:
            self.layer_object["leitung"] = QgsProject.instance().mapLayer(allg_dict["Leitung_layer_id"]).clone()
            self.leitung_defined = True
        except:
            self.leitung_defined = False

        #dict in das features gespeichert werden
        self.features = {}

    def select_object(self, selection_layer, name_shown, object_type):
        """
        Aktion zum Wählen einer Haltung
        """
        self.selection = selectTool(iface = self.iface,
                                    name_shown = name_shown, #Attribut das in Auswahl angezeigt wird
                                    selection_layer = selection_layer
                                    )
        #self.selection.featureIdentified.connect(self.con)
        self.selection.objectFound.connect(lambda feature, object_type = object_type: self.feature_selected(feature, object_type))
        self.iface.mapCanvas().setMapTool(self.selection)

        #self.identify = QgsMapToolIdentifyFeature(self.iface.mapCanvas(), self.layer_object["haltung"])
        #self.identify.featureIdentified.connect(self.con)
        
        #self.iface.mapCanvas().setMapTool(self.identify)
    
    def feature_selected(self,feature, object_type):
        if object_type == "Haltung":
            self.features["haltung"] = feature
        elif object_type == "Schacht":
            self.features["schacht"] = feature
        elif object_type == "Leitung":
            self.features["leitung"] = feature
        self.load_layer(object_type = object_type)
    
    def change_col_haltungNr(self,text,valid=None):
        if valid != None:
            self.txt_haltungNr.setStyleSheet("")
            self.button_zoom_haltung.setEnabled(True)
        else:
            self.txt_haltungNr.setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.button_zoom_haltung.setEnabled(False)
        
    def change_col_schachtNr(self,text,valid=None):
        if valid != None:
            self.txt_schachtNr.setStyleSheet("")
            self.button_zoom_schacht.setEnabled(True)
        else:
            self.txt_schachtNr.setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.button_zoom_schacht.setEnabled(False)
    
    def change_col_leitungNr(self,text,valid=None):
        if valid != None:
            self.txt_leitungNr.setStyleSheet("")
            self.button_zoom_leitung.setEnabled(True)
        else:
            self.txt_leitungNr.setStyleSheet("QLineEdit::editable {background-color: orange;}")
            self.button_zoom_leitung.setEnabled(False)
        
    def load_layer_from_textField(self, object_type):
        self.setCursor(Qt.WaitCursor)
        if object_type == "Haltung":
            filter = self.layer_object["haltung"].subsetString()
            self.layer_object["haltung"].setSubsetString(f"{self.variablen['attribut_haltungNr']}='{self.txt_haltungNr.text()}'")
            print(self.layer_object["haltung"].subsetString())
            if self.layer_object["haltung"].featureCount() == 1:
                haltung_feature = QgsFeature()
                self.layer_object["haltung"].getFeatures().nextFeature(haltung_feature)
                self.features["haltung"] = haltung_feature
                self.load_layer(load_from_txt_field = True, object_type = object_type)
                self.change_col_haltungNr(text = "", valid = True)
                #self.txt_haltungNr.setText(self.features["haltung"].attribut(self.variablen["attribut_haltungNr"]))
            else:
                self.clear_all()
                self.iface.messageBar().pushMessage("Haltung nicht gefunden.", "Die angegebene Haltungsnummer ist ungültig.", level=Qgis.Warning, duration=2)
                self.button_zoom_haltung.setEnabled(False)
            self.layer_object["haltung"].setSubsetString(filter)
        elif object_type == "Schacht":
            filter = self.layer_object["schacht"].subsetString()
            self.layer_object["schacht"].setSubsetString(f"{self.variablen['attribut_schachtNr']}='{self.txt_schachtNr.text()}'")
            if self.layer_object["schacht"].featureCount() == 1:
                schacht_feature = QgsFeature()
                self.layer_object["schacht"].getFeatures().nextFeature(schacht_feature)
                self.features["schacht"] = schacht_feature
                self.load_layer(load_from_txt_field = True, object_type = object_type)
                self.change_col_schachtNr(text = "", valid = True)
            else:
                self.clear_all()
                self.iface.messageBar().pushMessage("Schacht nicht gefunden.", "Die angegebene Schachtnummer ist ungültig.", level=Qgis.Warning, duration=2)
                self.button_zoom_schacht.setEnabled(False)
            self.layer_object["schacht"].setSubsetString(filter)
        elif object_type == "Leitung":
            filter = self.layer_object["leitung"].subsetString()
            self.layer_object["leitung"].setSubsetString(f"{self.variablen['attribut_leitungNr']}='{self.txt_leitungNr.text()}'")
            if self.layer_object["leitung"].featureCount() == 1:
                leitung_feature = QgsFeature()
                self.layer_object["leitung"].getFeatures().nextFeature(leitung_feature)
                self.features["leitung"] = leitung_feature
                self.load_layer(load_from_txt_field = True, object_type = object_type)
                self.change_col_leitungNr(text = "", valid = True)
            else:
                self.clear_all()
                self.iface.messageBar().pushMessage("Leitung nicht gefunden.", "Die angegebene Leitungsnummer ist ungültig.", level=Qgis.Warning, duration=2)
                self.button_zoom_leitung.setEnabled(False)
            self.layer_object["leitung"].setSubsetString(filter)

        self.setCursor(Qt.ArrowCursor)

    def load_layer(self, object_type, load_from_txt_field = False):
        if object_type == "Haltung":            
            if not load_from_txt_field:
                self.txt_haltungNr.setText(self.features["haltung"].attribute(self.variablen["attribut_haltungNr"]))
            self.change_col_haltungNr(text = "", valid = True)        
            
            try:
                ergebnisDP = str(self.features["haltung"].attribute(self.variablen["attribut_ergebnisDP"]))
            except:
                ergebnisDP = 'NULL'
            if ergebnisDP == "NULL":
                ergebnisDP = "keine DP"
            self.txt_ergebnisDP.setText(ergebnisDP)
            self.change_col_ergebnisDP()

            #zustandsklasse = str(self.features["haltung"].attribute(self.variablen["attribut_zustandsklasse"]))
            #if zustandsklasse == "NULL":
            #    zustandsklasse = "-"
            self.load_haltung.emit()
        elif object_type == "Schacht":
            if not load_from_txt_field:
                self.txt_schachtNr.setText(self.features["schacht"].attribute(self.variablen["attribut_schachtNr"]))
            self.change_col_schachtNr(text = "", valid = True)        

           # zustandsklasse = str(self.features["schacht"].attribute(self.variablen["attribut_zustandsklasse_schacht"]))
           # if zustandsklasse == "NULL":
           #     zustandsklasse = "-"
            self.load_schacht.emit()
        if object_type == "Leitung":            
            if not load_from_txt_field:
                self.txt_leitungNr.setText(self.features["leitung"].attribute(self.variablen["attribut_leitungNr"]))
            self.change_col_leitungNr(text = "", valid = True)        
            
            try:
                ergebnisDP = str(self.features["leitung"].attribute(self.variablen["attribut_ergebnisDP"]))
            except:
                ergebnisDP = 'NULL'
            if ergebnisDP == "NULL":
                ergebnisDP = "keine DP"
            self.txt_ergebnisDP_leitung.setText(ergebnisDP)
            self.change_col_ergebnisDP_leitung()

            #self.load_leitung.emit()

        self.load_protokolle(object_type)
 
    def clear_all(self):
        # Haltung Tab
        self.combobox_tv.clear()
        self.combobox_druck.clear()
        self.combobox_video.clear()

        self.txt_tv_anzahl.setText("")
        self.txt_druck_anzahl.setText("")
        self.txt_video_anzahl.setText("")

        self.button_tv.setEnabled(False)
        self.button_druck.setEnabled(False)
        self.button_video.setEnabled(False)
        self.button_tv_video.setEnabled(False)

        # Schacht Tab
        self.combobox_protokoll.clear()
        self.combobox_video_schacht.clear()

        self.txt_protokoll_anzahl.setText("")
        self.txt_video_schacht_anzahl.setText("")

        self.button_protokoll.setEnabled(False)
        self.button_video_schacht.setEnabled(False)
        self.button_schacht_alles.setEnabled(False)

        #Leitung Tab wenn definiert
        if self.leitung_defined:
            self.combobox_tv_leitung.clear()
            self.combobox_druck_leitung.clear()
            self.combobox_video_leitung.clear()

            self.txt_tv_anzahl_leitung.setText("")
            self.txt_druck_anzahl_leitung.setText("")
            self.txt_video_anzahl_leitung.setText("")

            self.button_tv_leitung.setEnabled(False)
            self.button_druck_leitung.setEnabled(False)
            self.button_video_leitung.setEnabled(False)
            self.button_tv_video_leitung.setEnabled(False)
 
    def zoom_to_object(self,layer, id):
        layer.selectByIds([id], QgsVectorLayer.SetSelection)
        bbox = layer.boundingBoxOfSelected()
        self.iface.mapCanvas().setExtent(bbox)
        scale = self.setup_dict["zoom_massstab"]
        self.iface.mapCanvas().zoomScale(scale)
        self.iface.mapCanvas().refresh()

    def load_protokolle(self, object_type):
        if object_type == "Haltung":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_haltung"], "Protokolle_Haltung", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_haltungNr.text()}')")

            self.tv_pfad = []
            self.tv_datum = []
                
            self.video_pfad = []
            self.video_datum = []
                
            self.druck_pfad = []
            self.druck_datum = []

            for feature in protokolle.getFeatures():
                if "protokoll" in feature.attribute("bez"):
                    self.tv_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.tv_datum.append(feature.attribute("datum"))
                    else:
                        self.tv_datum.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_datum.append(feature.attribute("datum"))
                    else:
                        self.video_datum.append("1900-01-01 00:00:00")
                elif "druck" in feature.attribute("bez"):
                    self.druck_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.druck_datum.append(feature.attribute("datum"))
                    else:
                        self.druck_datum.append("1900-01-01 00:00:00")

            self.tv_datum_strp = self.tv_datum
            self.video_datum_strp = self.video_datum
            self.druck_datum_strp = self.druck_datum

            tv_zip = sorted(zip(self.tv_datum_strp,self.tv_datum,self.tv_pfad), reverse = True)
            self.tv_datum_strp = [a for a,b,c in tv_zip]
            #self.tv_datum = [a.strftime("%d.%m.%Y") for a,b,c in tv_zip]
            self.tv_datum = [a.toString("dd.MM.yyyy") for a,b,c in tv_zip]
            self.tv_pfad = [c for a,b,c in tv_zip]

            video_zip = sorted(zip(self.video_datum_strp, self.video_datum, self.video_pfad), reverse = True)
            self.video_datum_strp = [a for a,b,c in video_zip]
            #self.video_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_zip]
            self.video_datum = [a.toString("dd.MM.yyyy") for a,b,c in video_zip]
            self.video_pfad = [c for a,b,c in video_zip]

            druck_zip = sorted(zip(self.druck_datum_strp, self.druck_datum, self.druck_pfad), reverse = True)
            self.druck_datum_strp = [a for a,b,c in druck_zip]
            #self.druck_datum = [a.strftime("%d.%m.%Y") for a,b,c in druck_zip]
            self.druck_datum = [a.toString("dd.MM.yyyy") for a,b,c in druck_zip]
            self.druck_pfad = [c for a,b,c in druck_zip]

            if len(self.tv_pfad) == 0 and len(self.video_pfad) == 0 and len(self.druck_pfad) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu dieser Haltung wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_tv.clear()
            self.txt_tv_anzahl.setText("")
            if len(self.tv_pfad) != 0:
                tv_pfad_short = [os.path.basename(f) for f in self.tv_pfad]
                tv_list = [list(i) for i in zip(self.tv_datum,tv_pfad_short)]
                tv_list = [":  ".join(i) for i in tv_list]
                self.combobox_tv.addItems(tv_list)
                self.txt_tv_anzahl.setText(str(len(self.tv_pfad)))
                self.button_tv.setEnabled(True)
            else:
                self.button_tv.setEnabled(False)
            # auswahl für druckprüfung einfügen
            self.combobox_druck.clear()
            self.txt_druck_anzahl.setText("")
            if len(self.druck_pfad) != 0:
                druck_pfad_short = [os.path.basename(f) for f in self.druck_pfad]
                druck_list = [list(i) for i in zip(self.druck_datum, druck_pfad_short)]
                druck_list = [":   ".join(i) for i in druck_list]
                self.combobox_druck.addItems(druck_list)
                self.txt_druck_anzahl.setText(str(len(self.druck_pfad)))
                self.button_druck.setEnabled(True)
            else:
                self.button_druck.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video.clear()
            self.txt_video_anzahl.setText("")
            if len(self.video_pfad) != 0:
                video_pfad_short = [os.path.basename(f) for f in self.video_pfad]
                video_list = [list(i) for i in zip(self.video_datum, video_pfad_short)]
                video_list = [":   ".join(i) for i in video_list]
                self.combobox_video.addItems(video_list)
                self.txt_video_anzahl.setText(str(len(self.video_pfad)))
                self.button_video.setEnabled(True)
            else:
                self.button_video.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_pfad) != 0 and len(self.tv_pfad) != 0:
                self.button_tv_video.setEnabled(True)
            else:
                self.button_tv_video.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Haltung {self.txt_haltungNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)
        elif object_type == "Schacht":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_schacht"], "Protokolle_Schacht", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_schachtNr.text()}')")

            self.protokoll_pfad = []
            self.protokoll_datum = []
                
            self.video_schacht_pfad = []
            self.video_schacht_datum = []

            for feature in protokolle.getFeatures():
                if feature.attribute("bez") in ["protokoll", "erhebungsblatt", "aufmaßblatt", "aufmassblatt"]:
                    self.protokoll_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.protokoll_datum.append(feature.attribute("datum"))
                    else:
                        self.protokoll_datum.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_schacht_pfad.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_schacht_datum.append(feature.attribute("datum"))
                    else:
                        self.video_schacht_datum.append("1900-01-01 00:00:00")


            #self.protokoll_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.protokoll_datum] # alt weil früher als string gespeichert
            self.protokoll_datum_strp = self.protokoll_datum
            #self.video_schacht_datum_strp = [datetime.strptime(i, "%Y-%m-%d %H:%M:%S") for i in self.video_schacht_datum]# alt weil früher als string gespeichert
            self.video_schacht_datum_strp = self.video_schacht_datum

            protokoll_zip = sorted(zip(self.protokoll_datum_strp,self.protokoll_datum,self.protokoll_pfad), reverse = True)
            self.protokoll_datum_strp = [a for a,b,c in protokoll_zip]
            #self.protokoll_datum = [a.strftime("%d.%m.%Y") for a,b,c in protokoll_zip]
            self.protokoll_datum = [a.toString("dd.MM.yyyy") for a,b,c in protokoll_zip]
            self.protokoll_pfad = [c for a,b,c in protokoll_zip]

            video_schacht_zip = sorted(zip(self.video_schacht_datum_strp, self.video_schacht_datum, self.video_schacht_pfad), reverse = True)
            self.video_schacht_datum_strp = [a for a,b,c in video_schacht_zip]
            #self.video_schacht_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_schacht_zip]
            self.video_schacht_datum = [a.toString("dd.MM.yyyy") for a,b,c in video_schacht_zip]
            self.video_schacht_pfad = [c for a,b,c in video_schacht_zip]

            if len(self.protokoll_pfad) == 0 and len(self.video_schacht_pfad) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu diesem Schacht wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_protokoll.clear()
            self.txt_protokoll_anzahl.setText("")
            if len(self.protokoll_pfad) != 0:
                protokoll_pfad_short = [os.path.basename(f) for f in self.protokoll_pfad]
                protokoll_list = [list(i) for i in zip(self.protokoll_datum,protokoll_pfad_short)]
                protokoll_list = [":  ".join(i) for i in protokoll_list]
                self.combobox_protokoll.addItems(protokoll_list)
                self.txt_protokoll_anzahl.setText(str(len(self.protokoll_pfad)))
                self.button_protokoll.setEnabled(True)
            else:
                self.button_protokoll.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video_schacht.clear()
            self.txt_video_schacht_anzahl.setText("")
            if len(self.video_schacht_pfad) != 0:
                video_schacht_pfad_short = [os.path.basename(f) for f in self.video_schacht_pfad]
                video_schacht_list = [list(i) for i in zip(self.video_schacht_datum, video_schacht_pfad_short)]
                video_schacht_list = [":   ".join(i) for i in video_schacht_list]
                self.combobox_video_schacht.addItems(video_schacht_list)
                self.txt_video_schacht_anzahl.setText(str(len(self.video_schacht_pfad)))
                self.button_video_schacht.setEnabled(True)
            else:
                self.button_video_schacht.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_schacht_pfad) != 0 and len(self.protokoll_pfad) != 0:
                self.button_schacht_alles.setEnabled(True)
            else:
                self.button_schacht_alles.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Schacht {self.txt_schachtNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)
        
        elif object_type == "Leitung":
            protokolle = QgsVectorLayer(self.variablen["db_protokolle"]+"|layername="+self.variablen["layer_protokolle_leitung"], "Protokolle_Leitung", "ogr")
            protokolle.setSubsetString(f"lower(nr) = lower('{self.txt_leitungNr.text()}')")

            self.tv_pfad_leitung = []
            self.tv_datum_leitung = []
                
            self.video_pfad_leitung = []
            self.video_datum_leitung = []
                
            self.druck_pfad_leitung = []
            self.druck_datum_leitung = []

            for feature in protokolle.getFeatures():
                if "protokoll" in feature.attribute("bez"):
                    self.tv_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.tv_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.tv_datum_leitung.append("1900-01-01 00:00:00") # wenn datum fehlt
                elif "video" in feature.attribute("bez"):
                    self.video_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.video_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.video_datum_leitung.append("1900-01-01 00:00:00")
                elif "druck" in feature.attribute("bez"):
                    self.druck_pfad_leitung.append(feature.attribute("pfad"))
                    if feature.attribute("datum") != '':
                        self.druck_datum_leitung.append(feature.attribute("datum"))
                    else:
                        self.druck_datum_leitung.append("1900-01-01 00:00:00")
            
            self.tv_datum_leitung_strp = self.tv_datum_leitung
            self.video_datum_leitung_strp = self.video_datum_leitung
            self.druck_datum_leitung_strp = self.druck_datum_leitung

            tv_zip_leitung = sorted(zip(self.tv_datum_leitung_strp,self.tv_datum_leitung,self.tv_pfad_leitung), reverse = True)
            self.tv_datum_leitung_strp = [a for a,b,c in tv_zip_leitung]
            #self.tv_datum = [a.strftime("%d.%m.%Y") for a,b,c in tv_zip]
            self.tv_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in tv_zip_leitung]
            self.tv_pfad_leitung = [c for a,b,c in tv_zip_leitung]

            video_zip_leitung = sorted(zip(self.video_datum_leitung_strp, self.video_datum_leitung, self.video_pfad_leitung), reverse = True)
            self.video_datum_leitung_strp = [a for a,b,c in video_zip_leitung]
            #self.video_datum = [a.strftime("%d.%m.%Y") for a,b,c in video_zip]
            self.video_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in video_zip_leitung]
            self.video_pfad_leitung = [c for a,b,c in video_zip_leitung]

            druck_zip_leitung = sorted(zip(self.druck_datum_leitung_strp, self.druck_datum_leitung, self.druck_pfad_leitung), reverse = True)
            self.druck_datum_leitung_strp = [a for a,b,c in druck_zip_leitung]
            #self.druck_datum = [a.strftime("%d.%m.%Y") for a,b,c in druck_zip]
            self.druck_datum_leitung = [a.toString("dd.MM.yyyy") for a,b,c in druck_zip_leitung]
            self.druck_pfad_leitung = [c for a,b,c in druck_zip_leitung]

            if len(self.tv_pfad_leitung) == 0 and len(self.video_pfad_leitung) == 0 and len(self.druck_pfad_leitung) == 0:
                self.iface.messageBar().pushMessage("Fehlende Inspektionsdaten", "Zu dieser Leitung wurden keine Inspektionsdaten gefunden", level=Qgis.Warning, duration=3)
            
            # auswahl für tv einfügen
            self.combobox_tv_leitung.clear()
            self.txt_tv_anzahl_leitung.setText("")
            if len(self.tv_pfad_leitung) != 0:
                tv_pfad_short_leitung = [os.path.basename(f) for f in self.tv_pfad_leitung]
                tv_list_leitung = [list(i) for i in zip(self.tv_datum_leitung,tv_pfad_short_leitung)]
                tv_list_leitung = [":  ".join(i) for i in tv_list_leitung]
                self.combobox_tv_leitung.addItems(tv_list_leitung)
                self.txt_tv_anzahl_leitung.setText(str(len(self.tv_pfad_leitung)))
                self.button_tv_leitung.setEnabled(True)
            else:
                self.button_tv_leitung.setEnabled(False)
            # auswahl für druckprüfung einfügen
            self.combobox_druck_leitung.clear()
            self.txt_druck_anzahl_leitung.setText("")
            if len(self.druck_pfad_leitung) != 0:
                druck_pfad_short_leitung = [os.path.basename(f) for f in self.druck_pfad_leitung]
                druck_list = [list(i) for i in zip(self.druck_datum_leitung, druck_pfad_short_leitung)]
                druck_list = [":   ".join(i) for i in druck_list]
                self.combobox_druck_leitung.addItems(druck_list)
                self.txt_druck_anzahl_leitung.setText(str(len(self.druck_pfad_leitung)))
                self.button_druck_leitung.setEnabled(True)
            else:
                self.button_druck_leitung.setEnabled(False)
            # auwahl für video einfügen
            self.combobox_video_leitung.clear()
            self.txt_video_anzahl_leitung.setText("")
            if len(self.video_pfad_leitung) != 0:
                video_pfad_short = [os.path.basename(f) for f in self.video_pfad_leitung]
                video_list = [list(i) for i in zip(self.video_datum_leitung, video_pfad_short)]
                video_list = [":   ".join(i) for i in video_list]
                self.combobox_video_leitung.addItems(video_list)
                self.txt_video_anzahl_leitung.setText(str(len(self.video_pfad_leitung)))
                self.button_video_leitung.setEnabled(True)
            else:
                self.button_video_leitung.setEnabled(False)
            
            #button tv-protokoll+video ein bzw ausschalten
            if len(self.video_pfad_leitung) != 0 and len(self.tv_pfad_leitung) != 0:
                self.button_tv_video_leitung.setEnabled(True)
            else:
                self.button_tv_video_leitung.setEnabled(False)
            self.iface.messageBar().pushMessage("Inspektionsdaten geladen.", f"Inspektionsdaten von Leitung {self.txt_haltungNr.text()} erfolgreich geladen.", level=Qgis.Success, duration=2)

    def open_file(self,file1, file2 = None, file3 = None):
        if file1 != None:
            try:
                os.startfile(file1)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file1}</b><br>konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")
        if file2 != None:
            try:
                os.startfile(file2)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file2}</b><br> konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")
        if file3 != None:
            try:
                os.startfile(file3)
            except:
                QMessageBox.warning(self,"Fehler!",f"Datei<br><b>{file3}</b><br>konnte nicht geöffnet werden.<br>Womöglich wurde die Datei verschoben.<br>Funktion 'Inspektionsdaten verknüpfen' erneut ausführen und neue Datenbank erstellen'")


    def change_col_ergebnisDP(self):
        if "undicht" in self.txt_ergebnisDP.text():
            self.txt_ergebnisDP.setStyleSheet("QLabel {background-color: #ff3030;}")
        elif "dicht" in self.txt_ergebnisDP.text().lower():
            self.txt_ergebnisDP.setStyleSheet("QLabel {background-color: #aaff00;}")
        elif "keine" in self.txt_ergebnisDP.text() or "nicht" in self.txt_ergebnisDP.text():
            self.txt_ergebnisDP.setStyleSheet("QLabel {background-color: orange;}")
        else:
            self.txt_ergebnisDP.setStyleSheet("")
    
    def change_col_ergebnisDP_leitung(self):
        if "undicht" in self.txt_ergebnisDP_leitung.text():
            self.txt_ergebnisDP_leitung.setStyleSheet("QLabel {background-color: #ff3030;}")
        elif "dicht" in self.txt_ergebnisDP_leitung.text().lower():
            self.txt_ergebnisDP_leitung.setStyleSheet("QLabel {background-color: #aaff00;}")
        elif "keine" in self.txt_ergebnisDP_leitung.text() or "nicht" in self.txt_ergebnisDP_leitung.text():
            self.txt_ergebnisDP_leitung.setStyleSheet("QLabel {background-color: orange;}")
        else:
            self.txt_ergebnisDP_leitung.setStyleSheet("")
