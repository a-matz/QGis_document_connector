# -*- coding: utf-8 -*-
"""
/***************************************************************************
 KanalManagementDockWidget
                                 A QGIS plugin
 Werkzeuge rund um das Kanalmanagement
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-12-10
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Armin Matzl
        email                : arminmatzl@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json
import glob
import pandas as pd
from osgeo import ogr
from datetime import datetime
import sqlite3
from qgis.PyQt.QtCore import Qt, QVariant, pyqtSignal #,QRegExp, QLine, , QSignalBlocker
from qgis.PyQt import QtGui, QtWidgets, uic
#from qgis.utils import iface
from qgis.core import QgsExpressionContextUtils, QgsProject, QgsVectorFileWriter,QgsProcessing, QgsField, QgsVectorLayer
from qgis.PyQt.QtWidgets import QDialog,QMessageBox, QProgressDialog
import processing
# eigene klassen

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'protokolle_verknuepfen.ui'))


class KanalProtokolleVerknuepfen(QtWidgets.QDialog, FORM_CLASS):

    #closingPlugin = pyqtSignal()
    okpressed = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(KanalProtokolleVerknuepfen, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        #self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)

        self.directory_outputDB.fileChanged.connect(self.check_input)
        self.directory_files.fileChanged.connect(self.check_input)
        self.directory_outputDB.setFilter("Geopackage (*.gpkg)")
        
        self.check_input()
        try:
            self.setup_dict = json.loads(QgsExpressionContextUtils.projectScope(QgsProject.instance()).variable('Kanalmanagement_Setup'))
            self.load_variables()
        except:
            self.setup_dict = None

        
        #self.check_input()

    def check_input(self):
        if os.path.isdir(self.directory_files.filePath()) and os.path.isdir(os.path.dirname(self.directory_outputDB.filePath())):
            self.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(True)
        else:
            self.buttonBox.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)

    def load_variables(self):
        if isinstance(self.setup_dict,dict):
            if "protokolle_setup" in self.setup_dict:
                self.directory_outputDB.setFilePath(self.setup_dict["protokolle_setup"]["db_protokolle_path"])

    def write_path(self):
        if self.setup_dict == None or not isinstance(self.setup_dict,dict):
            self.setup_dict = {}
            self.setup_dict["protokolle_setup"] = {}
            self.setup_dict["protokolle_setup"]["db_protokolle_path"] = self.directory_outputDB.filePath()
        elif "protokolle_setup" not in self.setup_dict:
            self.setup_dict["protokolle_setup"] = {}
            self.setup_dict["protokolle_setup"]["db_protokolle_path"] = self.directory_outputDB.filePath()
        else:
            self.setup_dict["protokolle_setup"]["db_protokolle_path"] = self.directory_outputDB.filePath()
        
        dict_string = json.dumps(self.setup_dict)
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(),'Kanalmanagement_Setup',dict_string)
        
    def remove_duplicates(self, tabelle):
        db = self.directory_outputDB.filePath()
        alg_params = {
            'FIELDS': ['pfad'],
            'INPUT' : db + f"|layername={tabelle}",
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }

        out = processing.run('native:removeduplicatesbyattribute', alg_params)
        out_layer = out["OUTPUT"]

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer 
        options.layerName = tabelle
        _writer = QgsVectorFileWriter.writeAsVectorFormat(out_layer, db, options)

    
    def accept(self):
        #prog = QProgressDialog("Suche Dateien..", "Cancel", 0, 1)
        #prog.setWindowModality(Qt.WindowModal)
        
        self.setCursor(Qt.WaitCursor)
        if self.checkbox_subdir.isChecked():
            files = glob.glob(self.directory_files.filePath() + '/**/*', recursive=True)
        else:
            files = glob.glob(self.directory_files.filePath() + "/*")

        #prog.setMaximum(len(files)-1)

        datei = [d for d in files if os.path.isfile(d)]
        objekt = {
        "pfad" : [],
        "nr" : [],
        "typ" : [],
        "bez" : [],
        "datum" : [],
        "zusatz" : [],
        "endung" : []
        }

        for i,f in enumerate(datei):
            
            #if prog.wasCanceled():
            #    break
            name, extension = os.path.splitext(f)
            #name = name.lower()
            typen = os.path.basename(name).split("_")
            if len(typen) > 3:
                objekt["pfad"].append(f)
                #objekt["nr"].append(typen[0].upper())
                objekt["nr"].append(typen[0].replace("mw","MW").replace("rw", "RW").replace("sw", "SW")) # falls systembezeichnung kleingeschrieben ist korrigieren
                objekt["typ"].append(typen[1].lower())
                objekt["bez"].append(typen[2].lower())
                try:
                    objekt["datum"].append(datetime.strptime(typen[3].strip(), "%Y%m%d"))
                except:
                    objekt["datum"].append(datetime.strptime("19800101".strip(), "%Y%m%d"))
                objekt["endung"].append(extension.replace(".","").lower())
                if len(typen) > 4:
                    objekt["zusatz"].append("-".join(typen[4:]))
                else:
                    objekt["zusatz"].append("")
            # wenn eine Datei kein Datum hat dann trotzdem übernehmen - Anlass:Schachterhebungsblätter in Lustenau haben oft kein Datum
            elif len(typen) == 3:
                objekt["pfad"].append(f)
                #objekt["nr"].append(typen[0].upper())
                objekt["nr"].append(typen[0].replace("mw","MW").replace("rw", "RW").replace("sw", "SW")) # falls systembezeichnung kleingeschrieben ist korrigieren
                objekt["typ"].append(typen[1].lower())
                objekt["bez"].append(typen[2].lower())
                objekt["datum"].append(datetime.strptime("19800101".strip(), "%Y%m%d"))
                objekt["endung"].append(extension.replace(".","").lower())
                objekt["zusatz"].append("")
                
            #prog.setValue(i)
                    

        df = pd.DataFrame.from_dict(objekt)
        
        schacht_daten = df.loc[(df["typ"].isin(["s","bw"])) & ~df["endung"].isin(["txt","jpg","jpeg","dwg","bak"])]
        schacht_protokoll = df.loc[(df["typ"] == "s") & (df["bez"].isin(["erhebungsblatt","protokoll","aufmassblatt"])) & (df["endung"] != "txt")]
        schacht_video = df.loc[(df["typ"] == "s") & (df["bez"] == "video") & (df["endung"] != "txt")]
        
        haltung_daten = df.loc[(df["typ"].isin(["h","l"])) & ~df["endung"].isin(["txt","jpg","jpeg","dwg","ipf","bak"])]
        haltung_protokoll = df.loc[(df["typ"].isin(["h","l"])) & (df["bez"] == "tv-protokoll") & (df["endung"] != "txt")]
        haltung_video = df.loc[(df["typ"].isin(["h","l"])) & (df["bez"] == "tv-video") & (df["endung"] != "txt")]

        fin_db = self.directory_outputDB.filePath().replace("/","\\")

        if self.checkbox_append.isChecked() and os.path.isfile(fin_db):
            methode = "append"
        else:
            methode = "replace"
            # create new dbase
            gpkg_driver = ogr.GetDriverByName("GPKG")
            source = gpkg_driver.CreateDataSource(fin_db)
            attribute_list = [
                QgsField("pfad", QVariant.String),
                QgsField("nr",  QVariant.String),
                QgsField("typ", QVariant.String),
                QgsField("bez", QVariant.String),
                QgsField("datum", QVariant.Date),
                QgsField("zusatz", QVariant.String),
                QgsField("endung", QVariant.String)
                ]

            layer = QgsVectorLayer("None", "Inspektionsdaten", "memory")
            pr = layer.dataProvider()
            pr.addAttributes(attribute_list)
            layer.updateFields()
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            options.layerName = "Inspektionsdaten"
            _writer = QgsVectorFileWriter.writeAsVectorFormat(layer, fin_db, options)
            options.layerName = "Inspektionsdaten_Schacht"
            _writer = QgsVectorFileWriter.writeAsVectorFormat(layer, fin_db, options)
            options.layerName = "Inspektionsdaten_Haltung"
            _writer = QgsVectorFileWriter.writeAsVectorFormat(layer, fin_db, options)


        con = sqlite3.connect(fin_db)
        df.to_sql('Inspektionsdaten', con, if_exists="append", index = False)
        schacht_daten.to_sql('Inspektionsdaten_Schacht', con, if_exists="append", index = False)
        #schacht_protokoll.to_sql('schacht_protokolle', con, if_exists=methode, index = False)
        #schacht_video.to_sql('schacht_videos', con, if_exists=methode, index = False)
        haltung_daten.to_sql('Inspektionsdaten_Haltung', con, if_exists="append", index = False)
        #haltung_protokoll.to_sql('haltung_protokolle', con, if_exists=methode, index = False)
        #haltung_video.to_sql('haltung_videos', con, if_exists=methode, index = False)
        con.close()

        if self.checkbox_useInCurrentProject.isChecked():
            self.write_path()
        
        if self.checkbox_removeDuplicates.isChecked():
            self.remove_duplicates("Inspektionsdaten_Schacht")
            self.remove_duplicates("Inspektionsdaten_Haltung")

        self.close()
        self.setCursor(Qt.ArrowCursor)
        self.okpressed.emit()
        self.deleteLater()
        QMessageBox.information(self,"Information", "Protokolle erfolgreich eingelesen.")
    """   
    def reject(self):
        self.close()
    """